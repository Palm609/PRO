{"ast":null,"code":"import { isConstantNode, isFunctionNode, isOperatorNode, isParenthesisNode, isSymbolNode } from '../../../utils/is.js';\nimport { factory } from '../../../utils/factory.js';\nvar name = 'simplifyCore';\nvar dependencies = ['equal', 'isZero', 'add', 'subtract', 'multiply', 'divide', 'pow', 'ConstantNode', 'OperatorNode', 'FunctionNode', 'ParenthesisNode'];\nexport var createSimplifyCore = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    equal,\n    isZero,\n    add,\n    subtract,\n    multiply,\n    divide,\n    pow,\n    ConstantNode,\n    OperatorNode,\n    FunctionNode,\n    ParenthesisNode\n  } = _ref;\n  var node0 = new ConstantNode(0);\n  var node1 = new ConstantNode(1);\n  /**\n   * simplifyCore() performs single pass simplification suitable for\n   * applications requiring ultimate performance. In contrast, simplify()\n   * extends simplifyCore() with additional passes to provide deeper\n   * simplification.\n   *\n   * Syntax:\n   *\n   *     simplify.simplifyCore(expr)\n   *\n   * Examples:\n   *\n   *     const f = math.parse('2 * 1 * x ^ (2 - 1)')\n   *     math.simplify.simpifyCore(f)                          // Node {2 * x}\n   *     math.simplify('2 * 1 * x ^ (2 - 1)', [math.simplify.simpifyCore]) // Node {2 * x}\n   *\n   * See also:\n   *\n   *     derivative\n   *\n   * @param {Node} node\n   *     The expression to be simplified\n   */\n\n  function simplifyCore(node) {\n    if (isOperatorNode(node) && node.isUnary()) {\n      var a0 = simplifyCore(node.args[0]);\n\n      if (node.op === '+') {\n        // unary plus\n        return a0;\n      }\n\n      if (node.op === '-') {\n        // unary minus\n        if (isOperatorNode(a0)) {\n          if (a0.isUnary() && a0.op === '-') {\n            return a0.args[0];\n          } else if (a0.isBinary() && a0.fn === 'subtract') {\n            return new OperatorNode('-', 'subtract', [a0.args[1], a0.args[0]]);\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [a0]);\n      }\n    } else if (isOperatorNode(node) && node.isBinary()) {\n      var _a = simplifyCore(node.args[0]);\n\n      var a1 = simplifyCore(node.args[1]);\n\n      if (node.op === '+') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return a1;\n          } else if (isConstantNode(a1)) {\n            return new ConstantNode(add(_a.value, a1.value));\n          }\n        }\n\n        if (isConstantNode(a1) && isZero(a1.value)) {\n          return _a;\n        }\n\n        if (isOperatorNode(a1) && a1.isUnary() && a1.op === '-') {\n          return new OperatorNode('-', 'subtract', [_a, a1.args[0]]);\n        }\n\n        return new OperatorNode(node.op, node.fn, a1 ? [_a, a1] : [_a]);\n      } else if (node.op === '-') {\n        if (isConstantNode(_a) && a1) {\n          if (isConstantNode(a1)) {\n            return new ConstantNode(subtract(_a.value, a1.value));\n          } else if (isZero(_a.value)) {\n            return new OperatorNode('-', 'unaryMinus', [a1]);\n          }\n        } // if (node.fn === \"subtract\" && node.args.length === 2) {\n\n\n        if (node.fn === 'subtract') {\n          if (isConstantNode(a1) && isZero(a1.value)) {\n            return _a;\n          }\n\n          if (isOperatorNode(a1) && a1.isUnary() && a1.op === '-') {\n            return simplifyCore(new OperatorNode('+', 'add', [_a, a1.args[0]]));\n          }\n\n          return new OperatorNode(node.op, node.fn, [_a, a1]);\n        }\n      } else if (node.op === '*') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return node0;\n          } else if (equal(_a.value, 1)) {\n            return a1;\n          } else if (isConstantNode(a1)) {\n            return new ConstantNode(multiply(_a.value, a1.value));\n          }\n        }\n\n        if (isConstantNode(a1)) {\n          if (isZero(a1.value)) {\n            return node0;\n          } else if (equal(a1.value, 1)) {\n            return _a;\n          } else if (isOperatorNode(_a) && _a.isBinary() && _a.op === node.op) {\n            var a00 = _a.args[0];\n\n            if (isConstantNode(a00)) {\n              var a00a1 = new ConstantNode(multiply(a00.value, a1.value));\n              return new OperatorNode(node.op, node.fn, [a00a1, _a.args[1]], node.implicit); // constants on left\n            }\n          }\n\n          return new OperatorNode(node.op, node.fn, [a1, _a], node.implicit); // constants on left\n        }\n\n        return new OperatorNode(node.op, node.fn, [_a, a1], node.implicit);\n      } else if (node.op === '/') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return node0;\n          } else if (isConstantNode(a1) && (equal(a1.value, 1) || equal(a1.value, 2) || equal(a1.value, 4))) {\n            return new ConstantNode(divide(_a.value, a1.value));\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [_a, a1]);\n      } else if (node.op === '^') {\n        if (isConstantNode(a1)) {\n          if (isZero(a1.value)) {\n            return node1;\n          } else if (equal(a1.value, 1)) {\n            return _a;\n          } else {\n            if (isConstantNode(_a)) {\n              // fold constant\n              return new ConstantNode(pow(_a.value, a1.value));\n            } else if (isOperatorNode(_a) && _a.isBinary() && _a.op === '^') {\n              var a01 = _a.args[1];\n\n              if (isConstantNode(a01)) {\n                return new OperatorNode(node.op, node.fn, [_a.args[0], new ConstantNode(multiply(a01.value, a1.value))]);\n              }\n            }\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [_a, a1]);\n      }\n    } else if (isParenthesisNode(node)) {\n      var c = simplifyCore(node.content);\n\n      if (isParenthesisNode(c) || isSymbolNode(c) || isConstantNode(c)) {\n        return c;\n      }\n\n      return new ParenthesisNode(c);\n    } else if (isFunctionNode(node)) {\n      var args = node.args.map(simplifyCore).map(function (arg) {\n        return isParenthesisNode(arg) ? arg.content : arg;\n      });\n      return new FunctionNode(simplifyCore(node.fn), args);\n    } else {// cannot simplify\n    }\n\n    return node;\n  }\n\n  return simplifyCore;\n});","map":{"version":3,"names":["isConstantNode","isFunctionNode","isOperatorNode","isParenthesisNode","isSymbolNode","factory","name","dependencies","createSimplifyCore","_ref","equal","isZero","add","subtract","multiply","divide","pow","ConstantNode","OperatorNode","FunctionNode","ParenthesisNode","node0","node1","simplifyCore","node","isUnary","a0","args","op","isBinary","fn","_a","a1","value","a00","a00a1","implicit","a01","c","content","map","arg"],"sources":["C:/Users/never/OneDrive/เดสก์ท็อป/ReactMumer-main/node_modules/mathjs/lib/esm/function/algebra/simplify/simplifyCore.js"],"sourcesContent":["import { isConstantNode, isFunctionNode, isOperatorNode, isParenthesisNode, isSymbolNode } from '../../../utils/is.js';\nimport { factory } from '../../../utils/factory.js';\nvar name = 'simplifyCore';\nvar dependencies = ['equal', 'isZero', 'add', 'subtract', 'multiply', 'divide', 'pow', 'ConstantNode', 'OperatorNode', 'FunctionNode', 'ParenthesisNode'];\nexport var createSimplifyCore = /* #__PURE__ */factory(name, dependencies, (_ref) => {\n  var {\n    equal,\n    isZero,\n    add,\n    subtract,\n    multiply,\n    divide,\n    pow,\n    ConstantNode,\n    OperatorNode,\n    FunctionNode,\n    ParenthesisNode\n  } = _ref;\n  var node0 = new ConstantNode(0);\n  var node1 = new ConstantNode(1);\n  /**\n   * simplifyCore() performs single pass simplification suitable for\n   * applications requiring ultimate performance. In contrast, simplify()\n   * extends simplifyCore() with additional passes to provide deeper\n   * simplification.\n   *\n   * Syntax:\n   *\n   *     simplify.simplifyCore(expr)\n   *\n   * Examples:\n   *\n   *     const f = math.parse('2 * 1 * x ^ (2 - 1)')\n   *     math.simplify.simpifyCore(f)                          // Node {2 * x}\n   *     math.simplify('2 * 1 * x ^ (2 - 1)', [math.simplify.simpifyCore]) // Node {2 * x}\n   *\n   * See also:\n   *\n   *     derivative\n   *\n   * @param {Node} node\n   *     The expression to be simplified\n   */\n\n  function simplifyCore(node) {\n    if (isOperatorNode(node) && node.isUnary()) {\n      var a0 = simplifyCore(node.args[0]);\n\n      if (node.op === '+') {\n        // unary plus\n        return a0;\n      }\n\n      if (node.op === '-') {\n        // unary minus\n        if (isOperatorNode(a0)) {\n          if (a0.isUnary() && a0.op === '-') {\n            return a0.args[0];\n          } else if (a0.isBinary() && a0.fn === 'subtract') {\n            return new OperatorNode('-', 'subtract', [a0.args[1], a0.args[0]]);\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [a0]);\n      }\n    } else if (isOperatorNode(node) && node.isBinary()) {\n      var _a = simplifyCore(node.args[0]);\n\n      var a1 = simplifyCore(node.args[1]);\n\n      if (node.op === '+') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return a1;\n          } else if (isConstantNode(a1)) {\n            return new ConstantNode(add(_a.value, a1.value));\n          }\n        }\n\n        if (isConstantNode(a1) && isZero(a1.value)) {\n          return _a;\n        }\n\n        if (isOperatorNode(a1) && a1.isUnary() && a1.op === '-') {\n          return new OperatorNode('-', 'subtract', [_a, a1.args[0]]);\n        }\n\n        return new OperatorNode(node.op, node.fn, a1 ? [_a, a1] : [_a]);\n      } else if (node.op === '-') {\n        if (isConstantNode(_a) && a1) {\n          if (isConstantNode(a1)) {\n            return new ConstantNode(subtract(_a.value, a1.value));\n          } else if (isZero(_a.value)) {\n            return new OperatorNode('-', 'unaryMinus', [a1]);\n          }\n        } // if (node.fn === \"subtract\" && node.args.length === 2) {\n\n\n        if (node.fn === 'subtract') {\n          if (isConstantNode(a1) && isZero(a1.value)) {\n            return _a;\n          }\n\n          if (isOperatorNode(a1) && a1.isUnary() && a1.op === '-') {\n            return simplifyCore(new OperatorNode('+', 'add', [_a, a1.args[0]]));\n          }\n\n          return new OperatorNode(node.op, node.fn, [_a, a1]);\n        }\n      } else if (node.op === '*') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return node0;\n          } else if (equal(_a.value, 1)) {\n            return a1;\n          } else if (isConstantNode(a1)) {\n            return new ConstantNode(multiply(_a.value, a1.value));\n          }\n        }\n\n        if (isConstantNode(a1)) {\n          if (isZero(a1.value)) {\n            return node0;\n          } else if (equal(a1.value, 1)) {\n            return _a;\n          } else if (isOperatorNode(_a) && _a.isBinary() && _a.op === node.op) {\n            var a00 = _a.args[0];\n\n            if (isConstantNode(a00)) {\n              var a00a1 = new ConstantNode(multiply(a00.value, a1.value));\n              return new OperatorNode(node.op, node.fn, [a00a1, _a.args[1]], node.implicit); // constants on left\n            }\n          }\n\n          return new OperatorNode(node.op, node.fn, [a1, _a], node.implicit); // constants on left\n        }\n\n        return new OperatorNode(node.op, node.fn, [_a, a1], node.implicit);\n      } else if (node.op === '/') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return node0;\n          } else if (isConstantNode(a1) && (equal(a1.value, 1) || equal(a1.value, 2) || equal(a1.value, 4))) {\n            return new ConstantNode(divide(_a.value, a1.value));\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [_a, a1]);\n      } else if (node.op === '^') {\n        if (isConstantNode(a1)) {\n          if (isZero(a1.value)) {\n            return node1;\n          } else if (equal(a1.value, 1)) {\n            return _a;\n          } else {\n            if (isConstantNode(_a)) {\n              // fold constant\n              return new ConstantNode(pow(_a.value, a1.value));\n            } else if (isOperatorNode(_a) && _a.isBinary() && _a.op === '^') {\n              var a01 = _a.args[1];\n\n              if (isConstantNode(a01)) {\n                return new OperatorNode(node.op, node.fn, [_a.args[0], new ConstantNode(multiply(a01.value, a1.value))]);\n              }\n            }\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [_a, a1]);\n      }\n    } else if (isParenthesisNode(node)) {\n      var c = simplifyCore(node.content);\n\n      if (isParenthesisNode(c) || isSymbolNode(c) || isConstantNode(c)) {\n        return c;\n      }\n\n      return new ParenthesisNode(c);\n    } else if (isFunctionNode(node)) {\n      var args = node.args.map(simplifyCore).map(function (arg) {\n        return isParenthesisNode(arg) ? arg.content : arg;\n      });\n      return new FunctionNode(simplifyCore(node.fn), args);\n    } else {// cannot simplify\n    }\n\n    return node;\n  }\n\n  return simplifyCore;\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}