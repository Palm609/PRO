{"ast":null,"code":"/**\r\n * Polyspline (smoothed line) module.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Polyline } from \"./Polyline\";\nimport { registry } from \"../Registry\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $type from \"../../core/utils/Type\";\nimport * as $path from \"../../core/rendering/Path\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Draws a polysline. (smoothed multi-sigment line)\r\n *\r\n * @see {@link IPolysplineEvents} for a list of available events\r\n * @see {@link IPolysplineAdapters} for a list of available Adapters\r\n */\n\nvar Polyspline =\n/** @class */\nfunction (_super) {\n  __extends(Polyspline, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function Polyspline() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"Polyspline\";\n    _this.tensionX = 0.5;\n    _this.tensionY = 0.5;\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * Creats and adds an SVG path for the arc.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Polyspline.prototype.makePath = function () {\n    this._distance = 0;\n    var segments = this.segments;\n    var tensionX = this.tensionX;\n    var tensionY = this.tensionY;\n    this.allPoints = [];\n\n    if (segments && segments.length > 0) {\n      var path = \"\";\n      this._realSegments = [];\n\n      for (var i = 0, len = segments.length; i < len; i++) {\n        var points = segments[i];\n        var realPoints = [];\n\n        this._realSegments.push(realPoints);\n\n        if (points.length > 0) {\n          var first = points[0];\n          var last = points[points.length - 1];\n          var closed_1 = false;\n\n          if ($math.round(first.x, 3) == $math.round(last.x) && $math.round(first.y) == $math.round(last.y)) {\n            closed_1 = true;\n          }\n\n          path += $path.moveTo(points[0]);\n\n          for (var p = 0; p < points.length - 1; p++) {\n            var p0 = points[p - 1];\n            var p1 = points[p];\n            var p2 = points[p + 1];\n            var p3 = points[p + 2];\n\n            if (p === 0) {\n              p0 = points[p];\n            } else if (p == points.length - 2) {\n              p3 = points[p + 1];\n            }\n\n            if (!p3) {\n              p3 = p2;\n            }\n\n            if (p === 0) {\n              if (closed_1) {\n                p0 = points[points.length - 2];\n              } else {\n                p0 = points[i];\n              }\n            } else if (p == points.length - 2) {\n              if (closed_1) {\n                p3 = points[1];\n              } else {\n                p3 = points[p + 1];\n              }\n            }\n\n            var controlPointA = $math.getCubicControlPointA(p0, p1, p2, p3, tensionX, tensionY);\n            var controlPointB = $math.getCubicControlPointB(p0, p1, p2, p3, tensionX, tensionY);\n            path += $path.cubicCurveTo(p2, controlPointA, controlPointB); // now split to small segments so that we could have positionToPoint later\n\n            var stepCount = Math.ceil($math.getCubicCurveDistance(p1, p2, controlPointA, controlPointB, 20)) * 1.2;\n            var prevPoint = p1;\n\n            if (stepCount > 0) {\n              // not good for curved charts\n              //this.allPoints[0] = { x: points[0].x, y: points[0].y, angle: $math.getAngle(points[0], points[1]) };\n              //realPoints.push(this.allPoints[0]);\n              for (var s = 0; s <= stepCount; s++) {\n                var point = $math.getPointOnCubicCurve(p1, p2, controlPointA, controlPointB, s / stepCount);\n\n                if (point.x == prevPoint.x && point.y == prevPoint.y) {\n                  continue;\n                }\n\n                realPoints.push(point);\n                var angle = $math.round($math.getAngle(prevPoint, point), 5); //this.allPoints.push({ x: point.x, y: point.y, angle: angle });\n\n                this._distance += $math.getDistance(prevPoint, point);\n                this.allPoints[Math.floor(this._distance)] = {\n                  x: point.x,\n                  y: point.y,\n                  angle: angle\n                };\n                prevPoint = point;\n              }\n            } else {\n              realPoints.push(p0);\n            }\n          }\n        }\n\n        var allPoints = this.allPoints;\n\n        if (allPoints.length > 1) {\n          for (var i_1 = 0; i_1 < allPoints.length; i_1++) {\n            if (!allPoints[i_1]) {\n              if (i_1 > 1) {\n                allPoints[i_1] = allPoints[i_1 - 1];\n              } else {\n                for (var k = 1; k < allPoints.length; k++) {\n                  if (allPoints[k]) {\n                    allPoints[i_1] = allPoints[k];\n                    break;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      this.path = path;\n    }\n  };\n  /**\r\n   * Returns an index of the point that is closest to specified coordinates.\r\n   *\r\n   * @param   point  Reference point\r\n   * @return         Index\r\n   */\n\n\n  Polyspline.prototype.getClosestPointIndex = function (point) {\n    var points = this.allPoints;\n    var index;\n    var closest = Infinity;\n\n    if (points.length > 1) {\n      for (var p = 1; p < points.length; p++) {\n        var distance = $math.getDistance(point, points[p]);\n\n        if (distance < closest) {\n          index = p;\n          closest = distance;\n        }\n      }\n    }\n\n    return index;\n  };\n\n  Object.defineProperty(Polyspline.prototype, \"tensionX\", {\n    /**\r\n     * @return Tension\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"tensionX\");\n    },\n\n    /**\r\n     * Horizontal tension for the spline.\r\n     *\r\n     * Used by the line smoothing algorithm.\r\n     *\r\n     * @default 0.5\r\n     * @param value  Tension\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"tensionX\", value);\n      this.makePath();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Polyspline.prototype, \"tensionY\", {\n    /**\r\n     * @return Tension\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"tensionY\");\n    },\n\n    /**\r\n     * Vertical tension for the spline.\r\n     *\r\n     * Used by the line smoothing algorithm.\r\n     *\r\n     * @default 0.5\r\n     * @param value  Tensions\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"tensionY\", value, true);\n      this.makePath();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Converts relative position along the line (0-1) into pixel coordinates.\r\n   *\r\n   * @param position  Position (0-1)\r\n   * @return Coordinates\r\n   */\n\n  Polyspline.prototype.positionToPoint = function (position, extend) {\n    var deltaAngle = 0;\n    var allPoints = this.allPoints;\n    var len = allPoints.length;\n\n    if (!$type.isNumber(position)) {\n      position = 0;\n    }\n\n    if (len > 1) {\n      if (extend && len > 3) {\n        if (position < 0) {\n          if (position < -0.01) {\n            position = -0.01;\n          }\n\n          var f0 = allPoints[0];\n          var f1 = allPoints[1];\n          var x = f0.x - (f0.x - f1.x) * len * position;\n          var y = f0.y - (f0.y - f1.y) * len * position;\n          return {\n            x: x,\n            y: y,\n            angle: $math.getAngle(f0, f1)\n          };\n        } else if (position > 1) {\n          if (position > 1.01) {\n            position = 1.01;\n          }\n\n          var f0 = allPoints[allPoints.length - 2];\n          var f1 = allPoints[allPoints.length - 3];\n          var x = f0.x + (f0.x - f1.x) * len * (position - 1);\n          var y = f0.y + (f0.y - f1.y) * len * (position - 1);\n          return {\n            x: x,\n            y: y,\n            angle: $math.getAngle(f0, {\n              x: x,\n              y: y\n            })\n          };\n        } else if (position == 1) {\n          var point_1 = allPoints[allPoints.length - 1];\n          return {\n            x: point_1.x,\n            y: point_1.y,\n            angle: point_1.angle\n          };\n        }\n      } else {\n        if (position < 0) {\n          position = Math.abs(position);\n          deltaAngle = 180;\n        }\n\n        if (position >= 1) {\n          position = 0.9999999999999;\n        }\n      }\n\n      var point = allPoints[Math.floor(position * len)];\n      return {\n        x: point.x,\n        y: point.y,\n        angle: point.angle + deltaAngle\n      };\n    } else if (len == 1) {\n      var point = allPoints[0];\n      return {\n        x: point.x,\n        y: point.y,\n        angle: point.angle\n      };\n    } else {\n      return {\n        x: 0,\n        y: 0,\n        angle: 0\n      };\n    }\n  };\n\n  return Polyspline;\n}(Polyline);\n\nexport { Polyspline };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"Polyspline\"] = Polyspline;","map":{"version":3,"sources":["../../../../../src/.internal/core/elements/Polyspline.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Polyspline (smoothed line) module.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Polyline, IPolylineProperties, IPolylineAdapters, IPolylineEvents } from \"./Polyline\";\r\nimport { IPoint, IOrientationPoint } from \"../../core/defs/IPoint\";\r\nimport { registry } from \"../Registry\";\r\nimport * as $math from \"../../core/utils/Math\";\r\nimport * as $type from \"../../core/utils/Type\";\r\nimport * as $path from \"../../core/rendering/Path\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines properties for [[Polyspline]].\r\n */\r\nexport interface IPolysplineProperties extends IPolylineProperties {\r\n\r\n\t/**\r\n\t * Horizontal tension for the spline.\r\n\t *\r\n\t * Used by the line smoothing algorithm.\r\n\t *\r\n\t * @default 0.5\r\n\t */\r\n\ttensionX: number;\r\n\r\n\t/**\r\n\t * Vertical tension for the spline.\r\n\t *\r\n\t * Used by the line smoothing algorithm.\r\n\t *\r\n\t * @default 0.5\r\n\t */\r\n\ttensionY: number;\r\n\r\n}\r\n\r\n/**\r\n * Defines events for [[Polyspline]].\r\n */\r\nexport interface IPolysplineEvents extends IPolylineEvents { }\r\n\r\n/**\r\n * Defines adapters\r\n * Includes both the [[Adapter]] definitions and properties\r\n * @see {@link Adapter}\r\n */\r\nexport interface IPolysplineAdapters extends IPolylineAdapters, IPolysplineProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Draws a polysline. (smoothed multi-sigment line)\r\n *\r\n * @see {@link IPolysplineEvents} for a list of available events\r\n * @see {@link IPolysplineAdapters} for a list of available Adapters\r\n */\r\nexport class Polyspline extends Polyline {\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tpublic _properties!: IPolysplineProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tpublic _adapter!: IPolysplineAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: IPolysplineEvents;\r\n\r\n\t/**\r\n\t * Array of points of a spline with 1 px increment. used to get point by position\r\n\t */\r\n\tpublic allPoints: IOrientationPoint[];\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"Polyspline\";\r\n\r\n\t\tthis.tensionX = 0.5;\r\n\t\tthis.tensionY = 0.5;\r\n\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * Creats and adds an SVG path for the arc.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic makePath(): void {\r\n\t\tthis._distance = 0;\r\n\t\tlet segments = this.segments;\r\n\r\n\t\tlet tensionX: number = this.tensionX;\r\n\t\tlet tensionY: number = this.tensionY;\r\n\r\n\t\tthis.allPoints = [];\r\n\r\n\t\tif (segments && segments.length > 0) {\r\n\t\t\tlet path: string = \"\";\r\n\t\t\tthis._realSegments = [];\r\n\r\n\t\t\tfor (let i = 0, len = segments.length; i < len; i++) {\r\n\t\t\t\tlet points: IPoint[] = segments[i];\r\n\t\t\t\tlet realPoints: IPoint[] = [];\r\n\t\t\t\tthis._realSegments.push(realPoints);\r\n\r\n\t\t\t\tif (points.length > 0) {\r\n\r\n\t\t\t\t\tlet first: IPoint = points[0];\r\n\t\t\t\t\tlet last: IPoint = points[points.length - 1];\r\n\r\n\t\t\t\t\tlet closed: boolean = false;\r\n\r\n\t\t\t\t\tif ($math.round(first.x, 3) == $math.round(last.x) && $math.round(first.y) == $math.round(last.y)) {\r\n\t\t\t\t\t\tclosed = true;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tpath += $path.moveTo(points[0]);\r\n\r\n\t\t\t\t\tfor (let p = 0; p < points.length - 1; p++) {\r\n\r\n\t\t\t\t\t\tlet p0: IPoint = points[p - 1];\r\n\r\n\t\t\t\t\t\tlet p1: IPoint = points[p];\r\n\r\n\t\t\t\t\t\tlet p2: IPoint = points[p + 1];\r\n\r\n\t\t\t\t\t\tlet p3: IPoint = points[p + 2];\r\n\r\n\t\t\t\t\t\tif (p === 0) {\r\n\t\t\t\t\t\t\tp0 = points[p];\r\n\t\t\t\t\t\t} else if (p == points.length - 2) {\r\n\t\t\t\t\t\t\tp3 = points[p + 1];\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (!p3) {\r\n\t\t\t\t\t\t\tp3 = p2;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (p === 0) {\r\n\t\t\t\t\t\t\tif (closed) {\r\n\t\t\t\t\t\t\t\tp0 = points[points.length - 2];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\tp0 = points[i];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else if (p == points.length - 2) {\r\n\t\t\t\t\t\t\tif (closed) {\r\n\t\t\t\t\t\t\t\tp3 = points[1];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\tp3 = points[p + 1];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tlet controlPointA: IPoint = $math.getCubicControlPointA(p0, p1, p2, p3, tensionX, tensionY);\r\n\t\t\t\t\t\tlet controlPointB: IPoint = $math.getCubicControlPointB(p0, p1, p2, p3, tensionX, tensionY);\r\n\r\n\t\t\t\t\t\tpath += $path.cubicCurveTo(p2, controlPointA, controlPointB);\r\n\r\n\t\t\t\t\t\t// now split to small segments so that we could have positionToPoint later\r\n\t\t\t\t\t\tlet stepCount: number = Math.ceil($math.getCubicCurveDistance(p1, p2, controlPointA, controlPointB, 20)) * 1.2;\r\n\t\t\t\t\t\tlet prevPoint: IPoint = p1;\r\n\r\n\r\n\t\t\t\t\t\tif (stepCount > 0) {\r\n\r\n\t\t\t\t\t\t\t// not good for curved charts\r\n\t\t\t\t\t\t\t//this.allPoints[0] = { x: points[0].x, y: points[0].y, angle: $math.getAngle(points[0], points[1]) };\r\n\t\t\t\t\t\t\t//realPoints.push(this.allPoints[0]);\r\n\r\n\r\n\t\t\t\t\t\t\tfor (let s = 0; s <= stepCount; s++) {\r\n\r\n\t\t\t\t\t\t\t\tlet point = $math.getPointOnCubicCurve(p1, p2, controlPointA, controlPointB, s / stepCount);\r\n\r\n\t\t\t\t\t\t\t\tif (point.x == prevPoint.x && point.y == prevPoint.y) {\r\n\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\trealPoints.push(point);\r\n\r\n\t\t\t\t\t\t\t\tlet angle = $math.round($math.getAngle(prevPoint, point), 5);\r\n\r\n\t\t\t\t\t\t\t\t//this.allPoints.push({ x: point.x, y: point.y, angle: angle });\r\n\t\t\t\t\t\t\t\tthis._distance += $math.getDistance(prevPoint, point);\r\n\r\n\t\t\t\t\t\t\t\tthis.allPoints[Math.floor(this._distance)] = { x: point.x, y: point.y, angle: angle };\r\n\t\t\t\t\t\t\t\tprevPoint = point;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\trealPoints.push(p0);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet allPoints = this.allPoints;\r\n\t\t\t\tif (allPoints.length > 1) {\r\n\t\t\t\t\tfor (let i = 0; i < allPoints.length; i++) {\r\n\t\t\t\t\t\tif (!allPoints[i]) {\r\n\t\t\t\t\t\t\tif (i > 1) {\r\n\t\t\t\t\t\t\t\tallPoints[i] = allPoints[i - 1];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\tfor (let k = 1; k < allPoints.length; k++) {\r\n\t\t\t\t\t\t\t\t\tif (allPoints[k]) {\r\n\t\t\t\t\t\t\t\t\t\tallPoints[i] = allPoints[k];\r\n\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.path = path;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an index of the point that is closest to specified coordinates.\r\n\t * \r\n\t * @param   point  Reference point\r\n\t * @return         Index\r\n\t */\r\n\tpublic getClosestPointIndex(point: IPoint): number {\r\n\t\tlet points = this.allPoints;\r\n\r\n\t\tlet index: number;\r\n\r\n\t\tlet closest: number = Infinity;\r\n\t\tif (points.length > 1) {\r\n\t\t\tfor (let p = 1; p < points.length; p++) {\r\n\t\t\t\tlet distance = $math.getDistance(point, points[p]);\r\n\t\t\t\tif (distance < closest) {\r\n\t\t\t\t\tindex = p;\r\n\t\t\t\t\tclosest = distance;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn index;\r\n\t}\r\n\r\n\t/**\r\n\t * Horizontal tension for the spline.\r\n\t *\r\n\t * Used by the line smoothing algorithm.\r\n\t *\r\n\t * @default 0.5\r\n\t * @param value  Tension\r\n\t */\r\n\tpublic set tensionX(value: number) {\r\n\t\tthis.setPropertyValue(\"tensionX\", value);\r\n\t\tthis.makePath();\r\n\t}\r\n\r\n\t/**\r\n\t * @return Tension\r\n\t */\r\n\tpublic get tensionX(): number {\r\n\t\treturn this.getPropertyValue(\"tensionX\");\r\n\t}\r\n\r\n\t/**\r\n\t * Vertical tension for the spline.\r\n\t *\r\n\t * Used by the line smoothing algorithm.\r\n\t *\r\n\t * @default 0.5\r\n\t * @param value  Tensions\r\n\t */\r\n\tpublic set tensionY(value: number) {\r\n\t\tthis.setPropertyValue(\"tensionY\", value, true);\r\n\t\tthis.makePath();\r\n\t}\r\n\r\n\t/**\r\n\t * @return Tension\r\n\t */\r\n\tpublic get tensionY(): number {\r\n\t\treturn this.getPropertyValue(\"tensionY\");\r\n\t}\r\n\r\n\t/**\r\n\t * Converts relative position along the line (0-1) into pixel coordinates.\r\n\t *\r\n\t * @param position  Position (0-1)\r\n\t * @return Coordinates\r\n\t */\r\n\r\n\tpublic positionToPoint(position: number, extend?: boolean): IOrientationPoint {\r\n\r\n\t\tlet deltaAngle: number = 0;\r\n\r\n\t\tlet allPoints = this.allPoints;\r\n\t\tlet len = allPoints.length;\r\n\r\n\t\tif (!$type.isNumber(position)) {\r\n\t\t\tposition = 0;\r\n\t\t}\r\n\r\n\t\tif (len > 1) {\r\n\r\n\t\t\tif (extend && len > 3) {\r\n\t\t\t\tif (position < 0) {\r\n\r\n\t\t\t\t\tif (position < -0.01) {\r\n\t\t\t\t\t\tposition = -0.01;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet f0 = allPoints[0];\r\n\t\t\t\t\tlet f1 = allPoints[1];\r\n\r\n\t\t\t\t\tlet x = f0.x - (f0.x - f1.x) * len * position;\r\n\t\t\t\t\tlet y = f0.y - (f0.y - f1.y) * len * position;\r\n\r\n\t\t\t\t\treturn { x: x, y: y, angle: $math.getAngle(f0, f1) };\r\n\t\t\t\t}\r\n\t\t\t\telse if (position > 1) {\r\n\r\n\t\t\t\t\tif (position > 1.01) {\r\n\t\t\t\t\t\tposition = 1.01;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet f0 = allPoints[allPoints.length - 2];\r\n\t\t\t\t\tlet f1 = allPoints[allPoints.length - 3];\r\n\r\n\t\t\t\t\tlet x = f0.x + (f0.x - f1.x) * len * (position - 1);\r\n\t\t\t\t\tlet y = f0.y + (f0.y - f1.y) * len * (position - 1);\r\n\r\n\t\t\t\t\treturn { x: x, y: y, angle: $math.getAngle(f0, { x: x, y: y }) };\r\n\t\t\t\t}\r\n\t\t\t\telse if (position == 1) {\r\n\t\t\t\t\tlet point = allPoints[allPoints.length - 1]\r\n\t\t\t\t\treturn { x: point.x, y: point.y, angle: point.angle };\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif (position < 0) {\r\n\t\t\t\t\tposition = Math.abs(position);\r\n\t\t\t\t\tdeltaAngle = 180;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (position >= 1) {\r\n\t\t\t\t\tposition = 0.9999999999999;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\r\n\t\t\tlet point = allPoints[Math.floor(position * len)];\r\n\t\t\treturn { x: point.x, y: point.y, angle: point.angle + deltaAngle };\r\n\t\t}\r\n\t\telse if (len == 1) {\r\n\t\t\tlet point = allPoints[0];\r\n\t\t\treturn { x: point.x, y: point.y, angle: point.angle };\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn { x: 0, y: 0, angle: 0 };\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"Polyspline\"] = Polyspline;\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}