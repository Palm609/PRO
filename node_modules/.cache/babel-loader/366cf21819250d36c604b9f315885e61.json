{"ast":null,"code":"/**\r\n * Text class deals with all text placed on chart.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Container } from \"../Container\";\nimport { registry } from \"../Registry\";\nimport { getTextFormatter } from \"../formatters/TextFormatter\";\nimport { MultiDisposer } from \"../utils/Disposer\";\nimport { InterfaceColorSet } from \"../../core/utils/InterfaceColorSet\";\nimport * as $math from \"../utils/Math\";\nimport * as $utils from \"../utils/Utils\";\nimport * as $type from \"../utils/Type\";\nimport * as $dom from \"../utils/DOM\";\nimport { defaultRules, ResponsiveBreakpoints } from \"../utils/Responsive\";\n;\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Text is used to display highly configurable, data-enabled textual elements.\r\n *\r\n * ## Data Binding\r\n *\r\n * A Text element can dynamically parse and populate its contents with values\r\n * from a [[DataItem]].\r\n *\r\n * To activate such binding, set element's `dataItem` property.\r\n *\r\n * When activated, text contents will be parsed for special tags, e.g.:\r\n *\r\n * ```TypeScript\r\n * label.dataItem = myDataItem;\r\n * label.text = \"The title is: {title}\";\r\n * ```\r\n * ```JavaScript\r\n * label.dataItem = myDataItem;\r\n * label.text = \"The title is: {title}\";\r\n * ```\r\n *\r\n * The above will automatically replace \"{title}\" in the string with the\r\n * actual data value from `myDataItem`.\r\n *\r\n * Note, that most often dataItem is set by the Component.\r\n *\r\n *\r\n * @see {@link ILabelEvents} for a list of available events\r\n * @see {@link ILabelAdapters} for a list of available Adapters\r\n * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-strings/} for info on string formatting and data binding\r\n * @todo Vertical align\r\n * @important\r\n */\n\nvar Label =\n/** @class */\nfunction (_super) {\n  __extends(Label, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function Label() {\n    var _this = // Execute super's constructor\n    _super.call(this) || this;\n    /**\r\n     * Indicates if the whole text does not fit into max dimenstions set for it.\r\n     */\n\n\n    _this.isOversized = false; // Set this class name\n\n    _this.className = \"Label\";\n    _this.fill = new InterfaceColorSet().getFor(\"text\"); // not good to set this, as then these will appear on each label and values set on container won't be applied.\n    //this.textDecoration = \"none\";\n    //this.fontWeight = \"normal\";\n    // Set defaults\n\n    _this.wrap = false;\n    _this.truncate = false;\n    _this.fullWords = true;\n    _this.ellipsis = \"â€¦\";\n    _this.textAlign = \"start\";\n    _this.textValign = \"top\";\n    _this.layout = \"absolute\";\n    _this.baseLineRatio = -0.27; //this.pixelPerfect = true;\n\n    _this._positionPrecision = 1; // Add events to watch for maxWidth/maxHeight changes so that we can\n    // invalidate this\n\n    _this.events.on(\"maxsizechanged\", function () {\n      if (_this.inited) {\n        _this.handleMaxSize();\n      }\n    }, _this, false); // this solves strange bug when text just added to svg is 0x0\n\n\n    _this.events.once(\"validated\", _this.handleValidate, _this, false); // Aply theme\n\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * A placeholder method that is called **after** element finishes drawing\r\n   * itself.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Label.prototype.afterDraw = function () {\n    // since we removed validatePosition from sprite, we still need it here to handle rotated text\n    _super.prototype.afterDraw.call(this);\n\n    this.validatePosition();\n  };\n  /**\r\n   * Sets [[Paper]] instance to use to draw elements.\r\n   * @ignore\r\n   * @param paper Paper\r\n   * @return true if paper was changed, false, if it's the same\r\n   */\n\n\n  Label.prototype.setPaper = function (paper) {\n    var changed = _super.prototype.setPaper.call(this, paper);\n\n    if (changed) {\n      this.hardInvalidate();\n    }\n\n    return changed;\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  Label.prototype.handleValidate = function () {\n    if ((this.currentText || this.text) && (this.bbox.width == 0 || this.bbox.height == 0)) {\n      registry.events.once(\"exitframe\", this.hardInvalidate, this);\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  Label.prototype.handleMaxSize = function () {\n    if (this.bbox.width > this.availableWidth || this.bbox.width < this.availableWidth && (this.isOversized || this.truncate) || this.bbox.height > this.availableHeight || this.bbox.height < this.availableHeight && this.isOversized) {\n      this.invalidate();\n    } else {\n      this.alignSVGText();\n    }\n  };\n  /**\r\n   * [arrange description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   */\n\n\n  Label.prototype.arrange = function () {};\n  /**\r\n   * Updates current text according to data item and supported features.\r\n   * Returns `true` if current text has changed.\r\n   *\r\n   * @return Text changed?\r\n   */\n\n\n  Label.prototype.updateCurrentText = function () {\n    // Determine output format\n    var output, text;\n\n    if ($utils.isNotEmpty(this.html) && this.paper.supportsForeignObject()) {\n      // We favor HTML text if it's set and browser supports `foreignObject`\n      output = \"html\";\n      text = this.html;\n    } else {\n      output = \"svg\";\n      text = this.text;\n    } // Need to toString source?\n\n\n    if ($type.isObject(text)) {\n      text = text.toString();\n    } // Need to format text all the time\n\n\n    if ($type.hasValue(text) && text !== \"\") {\n      text = this.populateString(text, this.dataItem);\n    }\n\n    if (output == \"html\") {\n      if (this._adapterO) {\n        text = this._adapterO.apply(\"htmlOutput\", text);\n      }\n    } else {\n      if (this._adapterO) {\n        text = this._adapterO.apply(\"textOutput\", text);\n      }\n    } // Update the text\n\n\n    var changed = text != this.currentText || output != this._currentFormat;\n    this.currentText = text;\n    this._currentFormat = output;\n    return changed;\n  };\n  /**\r\n   * Hard invalidate means the text will be redrawn even if it hasn't changed.\r\n   * This is used when we change `fontSize`, `fontFamily`, or for some other\r\n   * reasons.\r\n   */\n\n\n  Label.prototype.hardInvalidate = function () {\n    this._prevStatus = \"\";\n    this.invalidate();\n  };\n  /**\r\n   * Gets line bbox, uses caching to save cpu\r\n   * @ignore\r\n   */\n\n\n  Label.prototype.getLineBBox = function (lineInfo) {\n    //let cacheKey = lineInfo.text + lineInfo.style;\n    //let lineBBox = this.getCache(cacheKey);\n    //if (!lineBBox) {\n    //lineBBox = lineInfo.element.getBBox();\n    //if (lineBBox.width != 0 && lineBBox.height != 0) {\n    //\tthis.setCache(cacheKey, lineBBox, 5000);\n    //}\n    //}\n    var element = lineInfo && lineInfo.element;\n    var node = element && element.node; // Check for the parent Node to avoid FF from throwing errors\n\n    if (node && node.parentNode) {\n      lineInfo.bbox = element.getBBox();\n    }\n  };\n  /**\r\n   * Draws the textual label.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Label.prototype.draw = function () {\n    // Draw super\n    _super.prototype.draw.call(this);\n\n    var oldW = this.bbox.width;\n    var oldH = this.bbox.height;\n    var topParent = this.topParent;\n\n    if (topParent) {\n      if (!topParent.maxWidth || !topParent.maxHeight) {\n        topParent.events.once(\"maxsizechanged\", this.hardInvalidate, this, false);\n        return;\n      }\n    } // Calculate max width and height\n\n\n    var maxWidth = $math.max(this.availableWidth - this.pixelPaddingLeft - this.pixelPaddingRight, 0);\n    var maxHeight = $math.max(this.availableHeight - this.pixelPaddingTop - this.pixelPaddingBottom, 0); // save\n\n    var status = maxHeight + \",\" + maxWidth + this.wrap + this.truncate + this.fullWords + this.rtl + this.ellipsis; // Update text\n\n    if (!this.updateCurrentText() && this.inited && this._prevStatus == status) {\n      return;\n    }\n\n    this._measuredWidth = 0;\n    this._measuredHeight = 0; // Reset\n\n    this.isOversized = false; // Determine output format\n\n    var output = this._currentFormat;\n    var text = this.currentText; // Empty string\n\n    if (!$type.hasValue(text) || text == \"\") {\n      this.element.attr({\n        display: \"none\"\n      });\n      return;\n    } // Chop up text into lines\n    // We're still processing SVG and HTML in the same way for now\n\n\n    var lines = text.split(\"\\n\"); // Do we need to go through the trouble of measuring lines\n    //let measure: boolean = true;// (lines.length > 1) || this.wrap;\n\n    this._prevStatus = status;\n    this.textAlign = this.textAlign; // need this to measure\n\n    var display = this.group.getAttr(\"display\");\n\n    if (display == \"none\") {\n      this.group.removeAttr(\"display\");\n    }\n\n    if (this.textPathElement) {\n      this.textPathElement.removeChildren();\n    } // SVG or HTML?\n\n\n    if (output === \"svg\") {\n      /**\r\n       * SVG\r\n       */\n      this.element.removeAttr(\"display\"); // Clear the element\n\n      var group = this.element;\n      this.resetBBox(); // Init state variables\n\n      var currentHeight = 0;\n      var currentFormat = \"\"; // Process each line\n\n      for (var i = 0; i < lines.length; i++) {\n        // Get line\n        var line = lines[i]; // Check if line is empty\n\n        if (line == \"\") {\n          // It is, let's just update currentHeight and go to the next one\n          // If it's the first line, we'll have to use arbirary line height,\n          // since there's nothing to measure. For subsequent lines we can take\n          // previous line's height\n          var tempElement = this.getSVGLineElement(\"\", 0);\n          tempElement.add(this.getSvgElement(\".\", getTextFormatter().translateStyleShortcuts(currentFormat)));\n          group.add(tempElement);\n          var offset = Math.ceil(tempElement.getBBox().height);\n\n          if (offset > 0) {\n            currentHeight += offset;\n          }\n\n          group.removeElement(tempElement); // Clear cache if necessary\n\n          var lineInfo_1 = this.getLineInfo(i);\n\n          if (lineInfo_1) {\n            lineInfo_1.text = \"\";\n            lineInfo_1.element.textContent = \"\";\n          }\n\n          continue;\n        } // Chunk up the line and process each chunk\n\n\n        var chunks = getTextFormatter().chunk(line, null, this.ignoreFormatting);\n        var currentLineHeight = 0;\n        var firstChunk = true;\n        var skipTextChunks = false; // Create line element or grab it from cache\n\n        var lineInfo = this.getLineInfo(i);\n\n        if (lineInfo) {\n          // Empty line\n          lineInfo.text = \"\";\n          lineInfo.element.textContent = \"\";\n        } else {\n          // Init new line info\n          lineInfo = {\n            \"text\": \"\",\n            \"element\": this.getSVGLineElement(\"\", 0),\n            \"complex\": false\n          }; // Create the line element\n          //lineInfo.element = this.getSVGLineElement(\"\", 0);\n          //lineElement = this.getSVGLineElement(\"\", 0);\n\n          group.add(lineInfo.element);\n        }\n\n        lineInfo.element.removeAttr(\"display\");\n        lineInfo.element.removeChildren(); // memory leak without this\n\n        if (this.textPathElement) {\n          lineInfo.element.add(this.textPathElement);\n        }\n        /*// @todo not needed anymore\r\n        if (this.rtl) {\r\n            chunks.reverse();\r\n        }*/\n        // Process each chunk\n\n\n        for (var x = 0; x < chunks.length; x++) {\n          // If there's more than one chunk, means the line is \"complex\"\n          if (x) {\n            lineInfo.complex = true;\n          } // Get chunk\n\n\n          var chunk = chunks[x]; // Is this chunk format or text?\n\n          if (chunk.type === \"format\") {\n            // Log current format, so that we can apply it to multiple lines if\n            // necessary\n            currentFormat = chunk.text;\n          } else {\n            // It's text block\n            // Need to skip?\n            // We do this when truncating. We can't just simply go ahead and\n            // abandon chunk processing as they might have formatting\n            // instructions in them that are relevant for subsequent lines\n            if (skipTextChunks) {\n              continue;\n            } // Add chunk to the current element\n            //lineInfo.element.content += $utils.trim(getTextFormatter().format(currentFormat + chunk.text, output));\n\n\n            lineInfo.text = chunk.text;\n            lineInfo.style = getTextFormatter().translateStyleShortcuts(currentFormat);\n            var tspan = this.getSvgElement(lineInfo.text, lineInfo.style);\n\n            if (this.textPathElement) {\n              this.textPathElement.add(tspan);\n            } else {\n              lineInfo.element.add(tspan);\n            }\n\n            this.getLineBBox(lineInfo);\n            lineInfo.bbox.width = Math.ceil(lineInfo.bbox.width); // Updated current line height\n\n            if (currentLineHeight < lineInfo.bbox.height) {\n              currentLineHeight = lineInfo.bbox.height;\n            } // Wrapping?\n\n\n            if ((this.wrap || this.truncate) && lineInfo.bbox.width > maxWidth) {\n              // Set oversized\n              this.isOversized = true; // Take temporary measurements\n\n              var lineText = lineInfo.element.textContent;\n              var avgCharWidth = lineInfo.bbox.width / lineText.length; // * .9;\n              // Calculate average number of symbols / width\n\n              var excessChars = $math.min(Math.ceil((lineInfo.bbox.width - maxWidth) / avgCharWidth), lineText.length); // Are we truncating or auto-wrapping text?\n\n              if (this.truncate) {\n                /**\r\n                 * Processing line truncation\r\n                 * With the addition of each text chunk we measure if current\r\n                 * line does not exceed maxWidth. If it does, we will stop\r\n                 * addition of further chunks as well as try to truncate\r\n                 * current or any number of previous chunks with an added\r\n                 * ellipsis\r\n                 */\n                // Indicator whether we need to add ellipsis to the current\n                // element, even if it fits. This is needed to indicate\n                // whether we have already removed some subsequent chunks in\n                // which case we need to add ellipsis.\n                var addEllipsis = false; // Process each child in the temporary line, until the whole\n                // line fits, preferably with an ellipsis\n                // TODO use iterator instead\n\n                var node_1 = lineInfo.element.node;\n\n                if (node_1 && node_1.childNodes) {\n                  for (var e = lineInfo.element.node.childNodes.length - 1; e >= 0; e--) {\n                    // Get current element\n                    var node_2 = lineInfo.element.node.childNodes[e]; // Add ellipsis only if previous chunk was removed in full\n                    // and this chunk already fits\n                    //if (addEllipsis && (bbox.width <= maxWidth)) {\n\n                    if (addEllipsis && lineInfo.bbox.width <= maxWidth) {\n                      // Add ellipsis\n                      node_2.textContent += \" \" + this.ellipsis; // Measure again (we need to make sure ellipsis fits)\n\n                      lineInfo.bbox = lineInfo.element.getBBox();\n                      lineInfo.bbox.width = Math.floor(lineInfo.bbox.width); // If it fits, we're done here\n                      // If it doesn't we continue rolling\n\n                      if (lineInfo.bbox.width <= maxWidth) {\n                        break;\n                      }\n                    }\n\n                    addEllipsis = false; // Get element text\n\n                    var elementText = node_2.textContent; // Calculate average number of symbols / width\n\n                    lineText = lineInfo.element.textContent;\n                    excessChars = $math.min(Math.ceil((lineInfo.bbox.width - maxWidth) / avgCharWidth), lineText.length); // Do this until we fit\n\n                    while (lineInfo.bbox.width > maxWidth && excessChars <= lineText.length && excessChars > 0) {\n                      // Calculate max available chars\n                      var maxChars = $math.max(lineText.length - excessChars - this.ellipsis.length, 1); // Is there anything left?\n\n                      if (maxChars <= 1) {\n                        // Nope, let's jump to the previous item\n                        // Set excess characters to zero so that this loop does\n                        // not repeat when it over\n                        excessChars = 0; // Add ellipsis to previous item\n                        // Subsequent iterations will check if the ellipsis fits\n\n                        if (e > 0) {\n                          // Indicating to add ellipsis to previous item\n                          addEllipsis = true; // Removing this node\n\n                          lineInfo.element.node.removeChild(node_2);\n                        }\n                      } // Truncate the text\n\n\n                      elementText = $utils.truncateWithEllipsis(elementText, maxChars, this.ellipsis, this.fullWords, this.rtl);\n\n                      if (elementText.length > maxChars && this.fullWords) {\n                        // Still too long?\n                        // Let's try truncating breaking words anyway\n                        elementText = $utils.truncateWithEllipsis(elementText, maxChars, this.ellipsis, false, this.rtl);\n                      } // Set truncated text\n\n\n                      node_2.textContent = elementText; // Measure again\n\n                      lineInfo.bbox = lineInfo.element.getBBox();\n                      lineInfo.bbox.width = Math.floor(lineInfo.bbox.width); // Increase excess characters count, just in case it still\n                      // doesn't fit and we have to go at it again\n\n                      excessChars = Math.ceil(excessChars * 1.1);\n                    } // Do not process further chunks\n\n\n                    skipTextChunks = true;\n                  }\n                }\n              } else {\n                /**\r\n                 * Processign auto-wrap\r\n                 * In this case we're going to be adding text chunks until\r\n                 * they don't fit into current line. Once that happens we will\r\n                 * inject the rest of the chunks to the next line\r\n                 */\n                // Get last node added and measure it\n                var node_3 = lineInfo.element.node;\n\n                if (node_3) {\n                  var lastNode = lineInfo.element.node.lastChild; // Init split lines\n\n                  var splitLines = void 0;\n\n                  while (lineInfo.bbox.width > maxWidth && excessChars <= lineText.length && excessChars > 0) {\n                    // Calculate max available chars\n                    var maxChars = $math.max(chunk.text.length - excessChars, 1); // Don't split the words mid-word if it's not the first chunk\n                    // in the line\n\n                    if (firstChunk) {\n                      // Split mid-word if necessary\n                      splitLines = $utils.splitTextByCharCount(chunk.text, maxChars, true, this.rtl);\n                    } else {\n                      // Don't split mid-word\n                      splitLines = $utils.splitTextByCharCount(chunk.text, maxChars, true, this.rtl); // Check if the first word is too long\n\n                      if (splitLines[0].length > maxChars || maxChars === 1) {\n                        // Yes - move the whole chunk to the next line\n                        // Remove the element we just added\n                        lineInfo.element.node.removeChild(lastNode); // Break out of the while on next cycle\n\n                        excessChars = 0;\n                      }\n                    } // Use the first line to update last item\n\n\n                    if (excessChars > 0) {\n                      lastNode.textContent = getTextFormatter().cleanUp($utils.trim(splitLines.shift()));\n                    } // Measure again, just in case\n\n\n                    lineInfo.bbox = lineInfo.element.getBBox();\n                    lineInfo.bbox.width = Math.floor(lineInfo.bbox.width); // Increase excess characters count, just in case it still\n                    // doesn't fit and we have to go at it again\n                    //excessChars = Math.ceil(excessChars * 1.05);\n\n                    excessChars++;\n                  } // Construct the rest of the line\n\n\n                  if (splitLines.length > 0) {\n                    var restOfLine = \"\"; // Add leftovers from splitting the current chunk\n\n                    if ($type.hasValue(splitLines)) {\n                      if (this.rtl) {\n                        restOfLine += splitLines.join(\"\") + currentFormat;\n                      } else {\n                        restOfLine += currentFormat + splitLines.join(\"\").replace(/([\\[\\]]{1})/g, \"$1$1\");\n                      }\n                    } // Add the rest of the chunks\n\n\n                    for (var c = x + 1; c < chunks.length; c++) {\n                      if (chunks[c].type == \"value\") {\n                        // We're escaping single square brackets that were\n                        // cleaned up by chunk() back to double square brackets\n                        // so that they are not being treated as format on\n                        // next pass.\n                        restOfLine += chunks[c].text.replace(/([\\[\\]]{1})/g, \"$1$1\");\n                      } else {\n                        restOfLine += chunks[c].text;\n                      }\n                    } // Inject the rest of the lines as chunks for subsequent\n\n\n                    lines.splice(i + 1, 0, restOfLine);\n                  } // Skip processing the rest of the chunks\n\n\n                  skipTextChunks = true;\n                }\n              }\n            } // Let's update the text's bbox with the line's one\n\n\n            if (this.bbox.width < lineInfo.bbox.width) {\n              this.bbox.width = lineInfo.bbox.width;\n            } // commented to avoid bug (seen on sankey link) where text is incorrectly aligned\n            //if (this.bbox.x > lineInfo.bbox.x) {\n            //this.bbox.x = lineInfo.bbox.x;\n            //}\n\n\n            this.bbox.height = currentHeight + currentLineHeight; // Position current line\n\n            if (!this.textPathElement) {\n              lineInfo.element.attr({\n                \"x\": \"0\",\n                \"y\": currentHeight + currentLineHeight,\n                \"dy\": $math.round(this.baseLineRatio * currentLineHeight, 3).toString()\n              });\n            } else {\n              lineInfo.element.attr({\n                \"dy\": -this.paddingBottom.toString()\n              });\n            }\n\n            firstChunk = false;\n          }\n        } // Trim the last item\n\n\n        var node = lineInfo.element.node;\n\n        if (node) {\n          var lastNode = node.lastChild;\n\n          if (lastNode) {\n            lastNode.textContent = this.rtl ? $utils.ltrim(lastNode.textContent) : $utils.rtrim(lastNode.textContent);\n          }\n        } // Increment collective height\n\n\n        currentHeight += currentLineHeight; // Save line cache\n\n        this.addLineInfo(lineInfo, i);\n      } // Check if maybe we need to hide the whole label if it doesn't fit\n\n\n      this.maybeHideOversized();\n      this.measureFailed = false;\n\n      if (this.bbox.width == 0 || this.bbox.height == 0) {\n        this.measureFailed = true;\n      } // Updated measured dims\n\n\n      this._measuredWidth = $math.round($math.max(this.bbox.width, this.pixelWidth - this.pixelPaddingLeft - this.pixelPaddingRight));\n      this._measuredHeight = $math.round($math.max(this.bbox.height, this.pixelHeight - this.pixelPaddingTop - this.pixelPaddingBottom)); // Align the lines\n\n      this.alignSVGText();\n      this.bbox.width = this._measuredWidth;\n      this.bbox.height = this._measuredHeight;\n\n      if (oldH != this._measuredHeight || oldW != this._measuredWidth) {\n        this.dispatch(\"transformed\");\n      }\n\n      this.hideUnused(lines.length);\n    } else {\n      /**\r\n       * HTML\r\n       */\n      this.element.removeAttr(\"display\");\n      this.resetBBox(); // Clear the element\n\n      var group = this.element;\n      group.removeChildren(); // Create a ForeignObject to use as HTML container\n\n      var fo = this.paper.foreignObject();\n      group.add(fo); // Set widths on foreignObject so that autosizing measurements work\n      // This will bet reset to actual content width/height\n\n      if (this.maxWidth) {\n        fo.attr({\n          width: this.maxWidth - this.pixelPaddingLeft - this.pixelPaddingRight\n        });\n      }\n\n      if (this.maxHeight) {\n        fo.attr({\n          height: this.maxHeight - this.pixelPaddingTop - this.pixelPaddingBottom\n        });\n      } // Create line element\n      //let lineElement: HTMLElement = this.getHTMLLineElement(getTextFormatter().format(this.html, output));\n\n\n      var lineElement = this.getHTMLLineElement(text);\n      fo.node.appendChild(lineElement); // Temporarily set to inline-block so we can measure real width and height\n\n      lineElement.style.display = \"inline-block\";\n      var clientWidth = lineElement.clientWidth;\n      var clientHeight = lineElement.clientHeight;\n      lineElement.style.display = \"block\";\n      this._bbox = {\n        x: 0,\n        y: 0,\n        width: clientWidth,\n        height: clientHeight\n      }; // Set exact dimensions of foreignObject so it is sized exactly as\n      // the content within (add one pixel to width so it does not wrap)\n\n      fo.attr({\n        width: clientWidth + 1,\n        height: clientHeight\n      }); // Check if maybe we need to hide the whole label if it doesn't fit\n\n      this.maybeHideOversized(); // Set measurements and update bbox\n\n      this._measuredWidth = $math.max(this.bbox.width, this.pixelWidth - this.pixelPaddingLeft - this.pixelPaddingRight);\n      this._measuredHeight = $math.max(this.bbox.height, this.pixelHeight - this.pixelPaddingTop - this.pixelPaddingBottom);\n      this.bbox.width = this._measuredWidth;\n      this.bbox.height = this._measuredHeight; // Don't let labels bleed out of the alotted area\n\n      if (this.truncate) {\n        lineElement.style.overflow = \"hidden\";\n      }\n\n      if (clientWidth > maxWidth || clientHeight > maxHeight) {\n        this.isOversized = true;\n      }\n    } // Set applicable styles\n\n\n    this.setStyles();\n    this.updateCenter();\n    this.updateBackground();\n\n    if (display == \"none\") {\n      this.group.attr({\n        display: \"none\"\n      });\n    }\n\n    if (this.pathElement) {\n      this.paper.appendDef(this.pathElement);\n    }\n  };\n  /**\r\n   * Hides element if it does not fit into available space\r\n   */\n\n\n  Label.prototype.maybeHideOversized = function () {\n    if (this.hideOversized) {\n      if (this.availableWidth < this.bbox.width || this.availableHeight < this.bbox.height) {\n        this.element.attr({\n          display: \"none\"\n        });\n        this.isOversized = true;\n      } else {\n        this.element.removeAttr(\"display\");\n        this.isOversized = false;\n      }\n    }\n  };\n  /**\r\n   * Aligns the lines horizontally ant vertically, based on properties.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Label.prototype.alignSVGText = function () {\n    // Get Group\n    var group = this.element;\n    var children = group.node.children || group.node.childNodes; // Is there anything to align?\n\n    if (!children || children && children.length == 0) {\n      return;\n    }\n\n    var width = this._measuredWidth;\n    var height = this._measuredHeight; // TODO maybe these aren't needed ?\n\n    $utils.used(this.pixelPaddingLeft);\n    $utils.used(this.pixelPaddingRight);\n    $utils.used(this.pixelPaddingTop);\n    $utils.used(this.pixelPaddingBottom);\n\n    if (this.rtl) {\n      group.attr({\n        \"direction\": \"rtl\"\n      });\n    } else {\n      group.removeAttr(\"direction\");\n    } // Process each line\n    //$iter.each(group.children.backwards().iterator(), (element) => {\n\n\n    for (var i = children.length - 1; i >= 0; i--) {\n      // Align horizontally\n      // Since we are using `text-anchor` for horizontal alignment, all we need\n      // to do here is move the `x` position\n      var node = children[i];\n      node.setAttribute(\"text-anchor\", this.textAlign);\n\n      if (this.textPathElement) {\n        node.removeAttribute(\"x\");\n        node.removeAttribute(\"y\");\n      } else {\n        switch (this.textAlign) {\n          case \"middle\":\n            node.setAttribute(\"x\", (width / 2).toString() + \"px\");\n            break;\n\n          case \"end\":\n            if (this.rtl) {} else {\n              node.setAttribute(\"x\", width.toString());\n            }\n\n            break;\n\n          default:\n            if (this.rtl) {\n              node.setAttribute(\"x\", width.toString());\n            } else {\n              node.removeAttribute(\"text-anchor\");\n            }\n\n            break;\n        }\n\n        var y = $type.toNumber(node.getAttribute(\"y\"));\n\n        switch (this.textValign) {\n          case \"middle\":\n            node.setAttribute(\"y\", ((y || 0) + (height - this.bbox.height) / 2).toString());\n            break;\n\n          case \"bottom\":\n            node.setAttribute(\"y\", ((y || 0) + height - this.bbox.height).toString());\n            break;\n\n          default:\n            node.setAttribute(\"y\", (y || 0).toString());\n            break;\n        }\n      }\n    }\n  };\n  /**\r\n   * Produces an SVG line element with formatted text.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text    Text to wrap into line\r\n   * @param y       Current line vertical position\r\n   * @return A DOM element\r\n   * @todo Implement HTML support\r\n   */\n\n\n  Label.prototype.getSVGLineElement = function (text, y) {\n    // Create a <text> node and set text\n    var element = this.paper.addGroup(\"text\");\n    element.textContent = text; // Set parameters\n\n    element.attr({\n      \"x\": \"0\" //\"alignment-baseline\": \"hanging\",\n      //\"baseline-shift\": \"-20%\",\n      //\"text-anchor\": \"center\"\n\n    }); // Set `y` position\n\n    if ($type.hasValue(y)) {\n      element.attr({\n        \"y\": y.toString()\n      });\n    } // Don't let labels blled out of the alotted area\n\n\n    if (this.truncate || this.wrap) {\n      element.attr({\n        \"overflow\": \"hidden\"\n      });\n    } // Add RTL?\n    // This has now been moved to this.alignSVGText()\n    // if (this.rtl) {\n    // \telement.attr({\n    // \t\t\"direction\": \"rtl\",\n    // \t\t//\"unicode-bidi\": \"bidi-override\"\n    // \t});\n    // }\n\n\n    return element;\n  };\n\n  Object.defineProperty(Label.prototype, \"rtl\", {\n    /**\r\n     * @return RTL?\r\n     */\n    get: function () {\n      if ($type.hasValue(this._rtl)) {\n        return this._rtl;\n      } else if (this._topParent) {\n        return this._topParent.rtl;\n      }\n\n      return false;\n    },\n\n    /**\r\n     * An RTL (right-to-left) setting.\r\n     *\r\n     * RTL may affect alignment, text, and other visual properties.\r\n     *\r\n     * If you set this on a top-level chart object, it will be used for all\r\n     * child elements, e.g. labels, unless they have their own `rtl` setting\r\n     * set directly on them.\r\n     *\r\n     * @param value  `true` for to use RTL\r\n     */\n    set: function (value) {\n      value = $type.toBoolean(value);\n      this._rtl = value;\n\n      if (this.element) {\n        this.alignSVGText();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Resets cached BBox.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n  Label.prototype.resetBBox = function () {\n    this._bbox = {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n  };\n  /**\r\n   * Creates and returns an HTML line element (`<div>`).\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Text to add\r\n   * @return `<div>` element reference\r\n   */\n\n\n  Label.prototype.getHTMLLineElement = function (text) {\n    // Create the <div> element\n    var div = document.createElement(\"div\");\n    div.innerHTML = text; // Set text alignment\n\n    switch (this.textAlign) {\n      case \"middle\":\n        div.style.textAlign = \"center\";\n        break;\n\n      case \"end\":\n        div.style.textAlign = \"right\";\n        break;\n    } // Disable or enable wrapping\n\n\n    if (this.wrap) {\n      div.style.wordWrap = \"break-word\";\n    } else {\n      div.style.whiteSpace = \"nowrap\";\n    } // Don't let labels bleed out of the alotted area\n    // Moved to `draw()` because setting \"hidden\" kills all measuring\n\n    /*if (this.truncate) {\r\n        div.style.overflow = \"hidden\";\r\n    }*/\n    // Set RTL-related styles\n\n\n    if (this.rtl) {\n      div.style.direction = \"rtl\"; //div.style.unicodeBidi = \"bidi-override\";\n    } // Translate some of the SVG styles into CSS\n\n\n    if ($type.hasValue(this.fill)) {\n      div.style.color = this.fill.toString();\n    }\n\n    return div;\n  };\n  /**\r\n   * Applies specific styles to text to make it not selectable, unless it is\r\n   * explicitly set as `selectable`.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Set styles via AMElement\r\n   */\n\n\n  Label.prototype.setStyles = function () {\n    var group = this.element;\n\n    if (!this.selectable || this.draggable || this.resizable || this.swipeable) {\n      group.addStyle({\n        \"webkitUserSelect\": \"none\",\n        \"msUserSelect\": \"none\"\n      });\n    } else if (this.selectable) {\n      group.removeStyle(\"webkitUserSelect\");\n      group.removeStyle(\"msUserSelect\");\n    }\n  };\n  /**\r\n   * Hides unused lines\r\n   */\n\n\n  Label.prototype.hideUnused = function (index) {\n    this.initLineCache();\n    var lines = this.getCache(\"lineInfo\");\n\n    if (lines.length >= index) {\n      for (var i = index; i < lines.length; i++) {\n        var line = lines[i];\n\n        if (line && line.element) {\n          line.element.attr({\n            \"display\": \"none\"\n          });\n        }\n      }\n    }\n  };\n\n  Object.defineProperty(Label.prototype, \"text\", {\n    /**\r\n     * @return SVG text\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"text\");\n    },\n\n    /**\r\n     * An SVG text.\r\n     *\r\n     * Please note that setting `html` will override this setting if browser\r\n     * supports `foreignObject` in SGV, such as most modern browsers excluding\r\n     * IEs.\r\n     *\r\n     * @param value  SVG Text\r\n     */\n    set: function (value) {\n      //this.setPropertyValue(\"html\", undefined);\n      this.setPropertyValue(\"text\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"path\", {\n    /**\r\n     * @return Path\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"path\");\n    },\n\n    /**\r\n     * An SVG path string to position text along. If set, the text will follow\r\n     * the curvature of the path.\r\n     *\r\n     * Location along the path can be set using `locationOnPath`.\r\n     *\r\n     * IMPORTANT: Only SVG text can be put on path. If you are using HTML text\r\n     * this setting will be ignored.\r\n     *\r\n     * @since 4.1.2\r\n     * @param  value  Path\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"path\", value, true)) {\n        if (this.pathElement) {\n          this.pathElement.dispose();\n        }\n\n        if (this.textPathElement) {\n          this.textPathElement.dispose();\n        }\n\n        this.pathElement = this.paper.add(\"path\");\n        this.pathElement.attr({\n          \"d\": value\n        });\n        this.pathElement.attr({\n          \"id\": \"text-path-\" + this.uid\n        });\n\n        this._disposers.push(this.pathElement);\n\n        this.textPathElement = this.paper.addGroup(\"textPath\");\n        this.textPathElement.attrNS($dom.XLINK, \"xlink:href\", \"#text-path-\" + this.uid); // TODO remove after https://bugzilla.mozilla.org/show_bug.cgi?id=455986 is fixed\n\n        this.textPathElement.attr({\n          \"path\": value\n        });\n\n        this._disposers.push(this.textPathElement);\n\n        this.hardInvalidate();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"locationOnPath\", {\n    /**\r\n     * @return Relatvie location on path\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"locationOnPath\");\n    },\n\n    /**\r\n     * Relative label location on `path`. Value range is from 0 (beginning)\r\n     * to 1 (end).\r\n     *\r\n     * Works only if you set `path` setting to an SVG path.\r\n     *\r\n     * @since 4.1.2\r\n     * @default 0\r\n     * @param  value  Relatvie location on path\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"locationOnPath\", value);\n\n      if (this.textPathElement) {\n        this.textPathElement.attr({\n          \"startOffset\": value * 100 + \"%\"\n        });\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"baseLineRatio\", {\n    /**\r\n     * @return Base line ratio\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"baseLineRatio\");\n    },\n\n    /**\r\n     * A ratio to calculate text baseline. Ralative distance from the bottom of\r\n     * the label.\r\n     *\r\n     * @since 4.4.2\r\n     * @default -0.27\r\n     * @param  value  Base line ratio\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"baseLineRatio\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"wrap\", {\n    /**\r\n     * @return Auto-wrap enabled or not\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"wrap\");\n    },\n\n    /**\r\n     * Enables or disables autowrapping of text.\r\n     *\r\n     * @param value  Auto-wrapping enabled\r\n     */\n    set: function (value) {\n      this.resetBBox();\n      this.setPropertyValue(\"wrap\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"truncate\", {\n    /**\r\n     * @return Truncate text?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"truncate\");\n    },\n\n    /**\r\n     * Indicates if text lines need to be truncated if they do not fit, using\r\n     * configurable `ellipsis` string.\r\n     *\r\n     * `truncate` overrides `wrap` if both are set to `true`.\r\n     *\r\n     * NOTE: For HTML text, this setting **won't** trigger a parser and actual\r\n     * line truncation with ellipsis. It will just hide everything that goes\r\n     * outside the label.\r\n     *\r\n     * @param value  trincate text?\r\n     */\n    set: function (value) {\n      this.resetBBox();\n      this.setPropertyValue(\"truncate\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"fullWords\", {\n    /**\r\n     * @return Truncate on full words?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"fullWords\");\n    },\n\n    /**\r\n     * If `truncate` is enabled, should Label try to break only on full words\r\n     * (`true`), or whenever needed, including middle of the word. (`false`)\r\n     *\r\n     * @default true\r\n     * @param value  Truncate on full words?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"fullWords\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"ellipsis\", {\n    /**\r\n     * @return Ellipsis string\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"ellipsis\");\n    },\n\n    /**\r\n     * Ellipsis character to use if `truncate` is enabled.\r\n     *\r\n     * @param value Ellipsis string\r\n     * @default \"...\"\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"ellipsis\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"selectable\", {\n    /**\r\n     * @return Text selectable?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"selectable\");\n    },\n\n    /**\r\n     * Forces the text to be selectable. This setting will be ignored if the\r\n     * object has some kind of interaction attached to it, such as it is\r\n     * `draggable`, `swipeable`, `resizable`.\r\n     *\r\n     * @param value  Text selectable?\r\n     * @default false\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"selectable\", value, true);\n      this.setStyles();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"textAlign\", {\n    /**\r\n     * @return Alignment\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"textAlign\");\n    },\n\n    /**\r\n     * Horizontal text alignment.\r\n     *\r\n     * Available choices:\r\n     * * \"start\"\r\n     * * \"middle\"\r\n     * * \"end\"\r\n     *\r\n     * @param value  Alignment\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"textAlign\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"textValign\", {\n    /**\r\n     * @ignore Exclude from docs (not used)\r\n     * @return Alignment\r\n     * @deprecated\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"textValign\");\n    },\n\n    /**\r\n     * Vertical text alignment.\r\n     *\r\n     * @ignore Exclude from docs (not used)\r\n     * @param value  Alignment\r\n     * @deprecated\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"textValign\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"html\", {\n    /**\r\n     * @return HTML content\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"html\");\n    },\n\n    /**\r\n     * Raw HTML to be used as text.\r\n     *\r\n     * NOTE: HTML text is subject to browser support. It relies on browsers\r\n     * supporting SVG `foreignObject` nodes. Some browsers (read IEs) do not\r\n     * support it. On those browsers, the text will fall back to basic SVG text,\r\n     * striping out all HTML markup and styling that goes with it.\r\n     *\r\n     * For more information about `foreignObject` and its browser compatibility\r\n     * refer to [this page](https://developer.mozilla.org/en/docs/Web/SVG/Element/foreignObject#Browser_compatibility).\r\n     *\r\n     * @param value HTML text\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"html\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"hideOversized\", {\n    /**\r\n     * @return Hide if text does not fit?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"hideOversized\");\n    },\n\n    /**\r\n     * Indicates whether the whole text should be hidden if it does not fit into\r\n     * its allotted space.\r\n     *\r\n     * @param value  Hide if text does not fit?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"hideOversized\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"ignoreFormatting\", {\n    /**\r\n     * @return Ignore formatting?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"ignoreFormatting\");\n    },\n\n    /**\r\n     * If set to `true` square-bracket formatting blocks will be treated as\r\n     * regular text.\r\n     *\r\n     * @default false\r\n     * @param value  Ignore formatting?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"ignoreFormatting\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Override `mesaureElement` so it does not get measure again, because\r\n   * internal `_bbox` is being updated by measuring routines in Text itself.\r\n   */\n\n  Label.prototype.measureElement = function () {};\n  /**\r\n   * Returns information about a line element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param index  Line index\r\n   * @return Line info object\r\n   */\n\n\n  Label.prototype.getLineInfo = function (index) {\n    this.initLineCache();\n    var lines = this.getCache(\"lineInfo\");\n    return lines.length > index ? lines[index] : undefined;\n  };\n  /**\r\n   * Adds a line to line info cache.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param line     Line info object\r\n   * @param index    Insert at specified index\r\n   */\n\n\n  Label.prototype.addLineInfo = function (line, index) {\n    this.initLineCache();\n    this.getCache(\"lineInfo\")[index] = line;\n  };\n  /**\r\n   * Checks if line cache is initialized and initializes it.\r\n   */\n\n\n  Label.prototype.initLineCache = function () {\n    if (!$type.hasValue(this.getCache(\"lineInfo\"))) {\n      this.setCache(\"lineInfo\", [], 0);\n    }\n  };\n  /**\r\n   * Sets a [[DataItem]] to use for populating dynamic sections of the text.\r\n   *\r\n   * Check the description for [[Text]] class, for data binding.\r\n   *\r\n   * @param dataItem Data item\r\n   */\n\n\n  Label.prototype.setDataItem = function (dataItem) {\n    if (this._sourceDataItemEvents) {\n      this._sourceDataItemEvents.dispose();\n    }\n\n    if (dataItem) {\n      this._sourceDataItemEvents = new MultiDisposer([dataItem.events.on(\"valuechanged\", this.invalidate, this, false), dataItem.events.on(\"workingvaluechanged\", this.invalidate, this, false), dataItem.events.on(\"calculatedvaluechanged\", this.invalidate, this, false), dataItem.events.on(\"propertychanged\", this.invalidate, this, false)]);\n    }\n\n    _super.prototype.setDataItem.call(this, dataItem);\n  };\n\n  Object.defineProperty(Label.prototype, \"availableWidth\", {\n    /**\r\n     * Returns available horizontal space.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @return Available width (px)\r\n     */\n    get: function () {\n      return $type.hasValue(this.maxWidth) ? this.maxWidth : this.pixelWidth;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"availableHeight\", {\n    /**\r\n     * Returns available vertical space.\r\n     *\r\n     * @return Available height (px)\r\n     */\n    get: function () {\n      return $type.hasValue(this.maxHeight) ? this.maxHeight : this.pixelHeight;\n    },\n    enumerable: true,\n    configurable: true\n  }); // temp, replacing textFormatter method\n\n  Label.prototype.getSvgElement = function (text, style) {\n    var element = this.paper.add(\"tspan\");\n    element.textContent = text;\n\n    if (style) {\n      element.node.setAttribute(\"style\", style);\n    }\n\n    return element;\n  };\n  /**\r\n   * Invalidates the whole element, including layout AND all its child\r\n   * elements.\r\n   */\n\n\n  Label.prototype.deepInvalidate = function () {\n    _super.prototype.deepInvalidate.call(this);\n\n    this.hardInvalidate();\n  };\n\n  Object.defineProperty(Label.prototype, \"readerTitle\", {\n    /**\r\n     * @return Title\r\n     */\n    get: function () {\n      var title = this.getPropertyValue(\"readerTitle\");\n\n      if (!title) {\n        title = this.populateString($utils.plainText($utils.isNotEmpty(this.html) ? this.html : this.text));\n      } else if (this.dataItem) {\n        title = this.populateString(title);\n      }\n\n      return title;\n    },\n\n    /**\r\n     * Screen reader title of the element.\r\n     *\r\n     * @param value Title\r\n     */\n    set: function (value) {\n      value = $type.toText(value);\n\n      if (this.setPropertyValue(\"readerTitle\", value)) {\n        this.applyAccessibility();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Label;\n}(Container);\n\nexport { Label };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"Label\"] = Label;\n/**\r\n * Add default responsive rules\r\n */\n\n/**\r\n * Hide labels added directly to chart, like titles if chart is short.\r\n */\n\ndefaultRules.push({\n  relevant: ResponsiveBreakpoints.heightXS,\n  state: function (target, stateId) {\n    if (target instanceof Label && target.parent && target.parent.isBaseSprite) {\n      var state = target.states.create(stateId);\n      state.properties.disabled = true;\n      return state;\n    }\n\n    return null;\n  }\n});","map":{"version":3,"sources":["../../../../../src/.internal/core/elements/Label.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Text class deals with all text placed on chart.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Container, IContainerProperties, IContainerAdapters, IContainerEvents } from \"../Container\";\r\nimport { DataItem } from \"../DataItem\";\r\nimport { TextValign } from \"../defs/TextValign\";\r\nimport { TextAlign } from \"../defs/TextAlign\";\r\nimport { IRectangle } from \"../defs/IRectangle\";\r\nimport { AMElement } from \"../rendering/AMElement\";\r\nimport { Group } from \"../rendering/Group\";\r\nimport { registry } from \"../Registry\";\r\nimport { ITextChunk, getTextFormatter } from \"../formatters/TextFormatter\";\r\nimport { MultiDisposer } from \"../utils/Disposer\";\r\nimport { InterfaceColorSet } from \"../../core/utils/InterfaceColorSet\";\r\nimport * as $math from \"../utils/Math\";\r\nimport * as $utils from \"../utils/Utils\";\r\nimport * as $type from \"../utils/Type\";\r\nimport { Paper } from \"../rendering/Paper\";\r\nimport * as $dom from \"../utils/DOM\";\r\nimport { defaultRules, ResponsiveBreakpoints } from \"../utils/Responsive\";\r\n\r\n\r\n/**\r\n * Defines properties for [[Text]].\r\n */\r\nexport interface ILabelProperties extends IContainerProperties {\r\n\r\n\t/**\r\n\t * Horizontal align of the text.\r\n\t *\r\n\t * @default \"start\"\r\n\t */\r\n\ttextAlign?: TextAlign;\r\n\r\n\t/**\r\n\t * Vertical align of the text.\r\n\t *\r\n\t * @default \"top\"\r\n\t */\r\n\ttextValign?: TextValign;\r\n\r\n\t/**\r\n\t * A plain text content.\r\n\t */\r\n\ttext?: string;\r\n\r\n\t/**\r\n\t * Should the lines wrap if they do not fit into max width?\r\n\t *\r\n\t * @default false\r\n\t */\r\n\twrap?: boolean;\r\n\r\n\t/**\r\n\t * Should the text be selectable>\r\n\t *\r\n\t * @default false\r\n\t */\r\n\tselectable?: boolean;\r\n\r\n\t/**\r\n\t * HTML content.\r\n\t */\r\n\thtml?: string;\r\n\r\n\t/**\r\n\t * Should the lines be truncated (optionally with ellipsis) if they do not\r\n\t * fit into max width?\r\n\t *\r\n\t * @default false\r\n\t */\r\n\ttruncate?: boolean;\r\n\r\n\t/**\r\n\t * If `truncate` is enabled, should Label try to break only on full words\r\n\t * (`true`), or whenever needed, including middle of the word. (`false`)\r\n\t *\r\n\t * @default true\r\n\t */\r\n\tfullWords?: boolean;\r\n\r\n\t/**\r\n\t * If lines are truncated, this ellipsis will be added at the end.\r\n\t *\r\n\t * @default \"â€¦\"\r\n\t */\r\n\tellipsis?: string;\r\n\r\n\t/**\r\n\t * Hide text of it does not fit into element's dimensions?\r\n\t *\r\n\t * @default false\r\n\t */\r\n\thideOversized?: boolean;\r\n\r\n\t/**\r\n\t * If set to `true` square-bracket formatting blocks will be treated as\r\n\t * regular text.\r\n\t *\r\n\t * @default false\r\n\t */\r\n\tignoreFormatting?: boolean;\r\n\r\n\t/**\r\n\t * Path string along which text should be arranged\r\n\t */\r\n\tpath?: string\r\n\r\n\t/**\r\n\t * Relative label location on path.\r\n\t */\r\n\tlocationOnPath?: number;\r\n\r\n\t/**\r\n\t * A ratio to calculate text baseline. Ralative distance from the bottom of\r\n\t * the label.\r\n\t *\r\n\t * @default -0.27\r\n\t */\r\n\tbaseLineRatio?: number;\r\n}\r\n\r\n/**\r\n * Text line information.\r\n *\r\n * Objects used to hold cached information about lines in a Text element.\r\n */\r\nexport interface ITextLineInfo {\r\n\r\n\t/**\r\n\t * Measurements for the bounding box of the line.\r\n\t */\r\n\t\"bbox\"?: IRectangle,\r\n\r\n\t/**\r\n\t * A reference to an SVG `<g>` element that holds line elements.\r\n\t */\r\n\t\"element\"?: Group,\r\n\r\n\t/**\r\n\t * Indicates if line contains more than one element, e.g. has multiple\r\n\t * formatted blocks.\r\n\t */\r\n\t\"complex\"?: boolean,\r\n\r\n\t\"text\"?: string,\r\n\r\n\t\"style\"?: string\r\n};\r\n\r\n/**\r\n * Defines events for [[Text]].\r\n */\r\nexport interface ILabelEvents extends IContainerEvents { }\r\n\r\n/**\r\n * Adapters for [[Text]].\r\n *\r\n * Includes both the [[Adapter]] definitions and properties.\r\n *\r\n * @see {@link Adapter}\r\n */\r\nexport interface ILabelAdapters extends IContainerAdapters, ILabelProperties {\r\n\r\n\t/**\r\n\t * Applied to the final formatted label text.\r\n\t */\r\n\ttextOutput: string;\r\n\r\n\t/**\r\n\t * Applied to the final formatted label HTML.\r\n\t */\r\n\thtmlOutput: string;\r\n\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Text is used to display highly configurable, data-enabled textual elements.\r\n *\r\n * ## Data Binding\r\n *\r\n * A Text element can dynamically parse and populate its contents with values\r\n * from a [[DataItem]].\r\n *\r\n * To activate such binding, set element's `dataItem` property.\r\n *\r\n * When activated, text contents will be parsed for special tags, e.g.:\r\n *\r\n * ```TypeScript\r\n * label.dataItem = myDataItem;\r\n * label.text = \"The title is: {title}\";\r\n * ```\r\n * ```JavaScript\r\n * label.dataItem = myDataItem;\r\n * label.text = \"The title is: {title}\";\r\n * ```\r\n *\r\n * The above will automatically replace \"{title}\" in the string with the\r\n * actual data value from `myDataItem`.\r\n *\r\n * Note, that most often dataItem is set by the Component.\r\n *\r\n *\r\n * @see {@link ILabelEvents} for a list of available events\r\n * @see {@link ILabelAdapters} for a list of available Adapters\r\n * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-strings/} for info on string formatting and data binding\r\n * @todo Vertical align\r\n * @important\r\n */\r\nexport class Label extends Container {\r\n\t/**\r\n\t * Defines available properties.\r\n\t */\r\n\tpublic _properties!: ILabelProperties;\r\n\r\n\t/**\r\n\t * Defines Adapter type.\r\n\t */\r\n\tpublic _adapter!: ILabelAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: ILabelEvents;\r\n\r\n\t/**\r\n\t * Indicates if the whole text does not fit into max dimenstions set for it.\r\n\t */\r\n\tpublic isOversized: boolean = false;\r\n\r\n\t/**\r\n\t * Currently formatted text, read only.\r\n\t */\r\n\tpublic currentText: string;\r\n\r\n\t/**\r\n\t * Current format to be used for outputing text.\r\n\t */\r\n\tprotected _currentFormat: string;\r\n\r\n\t/**\r\n\t * [_sourceDataItemEvents description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected _sourceDataItemEvents: MultiDisposer;\r\n\r\n\r\n\tprotected _prevStatus: string;\r\n\r\n\t/**\r\n\t * SVG path element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic pathElement: $type.Optional<AMElement>;\r\n\r\n\t/**\r\n\t * SVG textpath element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic textPathElement: $type.Optional<Group>;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\r\n\t\t// Execute super's constructor\r\n\t\tsuper();\r\n\r\n\t\t// Set this class name\r\n\t\tthis.className = \"Label\";\r\n\r\n\t\tthis.fill = new InterfaceColorSet().getFor(\"text\");\r\n\r\n\t\t// not good to set this, as then these will appear on each label and values set on container won't be applied.\r\n\t\t//this.textDecoration = \"none\";\r\n\t\t//this.fontWeight = \"normal\";\r\n\r\n\r\n\t\t// Set defaults\r\n\t\tthis.wrap = false;\r\n\t\tthis.truncate = false;\r\n\t\tthis.fullWords = true;\r\n\t\tthis.ellipsis = \"â€¦\";\r\n\t\tthis.textAlign = \"start\";\r\n\t\tthis.textValign = \"top\";\r\n\r\n\t\tthis.layout = \"absolute\";\r\n\t\tthis.baseLineRatio = -0.27;\r\n\t\t//this.pixelPerfect = true;\r\n\t\tthis._positionPrecision = 1;\r\n\r\n\t\t// Add events to watch for maxWidth/maxHeight changes so that we can\r\n\t\t// invalidate this\r\n\t\tthis.events.on(\"maxsizechanged\", () => {\r\n\t\t\tif (this.inited) {\r\n\t\t\t\tthis.handleMaxSize()\r\n\t\t\t}\r\n\t\t}, this, false);\r\n\r\n\t\t// this solves strange bug when text just added to svg is 0x0\r\n\t\tthis.events.once(\"validated\", this.handleValidate, this, false);\r\n\r\n\t\t// Aply theme\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * A placeholder method that is called **after** element finishes drawing\r\n\t * itself.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tprotected afterDraw(): void {\r\n\t\t// since we removed validatePosition from sprite, we still need it here to handle rotated text\r\n\t\tsuper.afterDraw();\r\n\t\tthis.validatePosition();\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Sets [[Paper]] instance to use to draw elements.\r\n\t * @ignore\r\n\t * @param paper Paper\r\n\t * @return true if paper was changed, false, if it's the same\r\n\t */\r\n\tpublic setPaper(paper: Paper): boolean {\r\n\r\n\t\tlet changed = super.setPaper(paper);\r\n\r\n\t\tif (changed) {\r\n\t\t\tthis.hardInvalidate();\r\n\t\t}\r\n\t\treturn changed;\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected handleValidate() {\r\n\t\tif ((this.currentText || this.text) && (this.bbox.width == 0 || this.bbox.height == 0)) {\r\n\t\t\tregistry.events.once(\"exitframe\", this.hardInvalidate, this);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected handleMaxSize() {\r\n\t\tif (\r\n\t\t\t(this.bbox.width > this.availableWidth)\r\n\t\t\t|| ((this.bbox.width < this.availableWidth) && (this.isOversized || this.truncate))\r\n\t\t\t|| (this.bbox.height > this.availableHeight)\r\n\t\t\t|| ((this.bbox.height < this.availableHeight) && this.isOversized)\r\n\t\t) {\r\n\t\t\tthis.invalidate();\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.alignSVGText();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * [arrange description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t */\r\n\tpublic arrange(): void {\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Updates current text according to data item and supported features.\r\n\t * Returns `true` if current text has changed.\r\n\t *\r\n\t * @return Text changed?\r\n\t */\r\n\tprotected updateCurrentText(): boolean {\r\n\t\t// Determine output format\r\n\t\tlet output: string, text: string;\r\n\r\n\t\tif ($utils.isNotEmpty(this.html) && this.paper.supportsForeignObject()) {\r\n\r\n\t\t\t// We favor HTML text if it's set and browser supports `foreignObject`\r\n\t\t\toutput = \"html\";\r\n\t\t\ttext = this.html;\r\n\t\t}\r\n\t\telse {\r\n\t\t\toutput = \"svg\";\r\n\t\t\ttext = this.text;\r\n\t\t}\r\n\r\n\t\t// Need to toString source?\r\n\t\tif ($type.isObject(text as any)) {\r\n\t\t\ttext = text.toString();\r\n\t\t}\r\n\r\n\t\t// Need to format text all the time\r\n\t\tif ($type.hasValue(text) && text !== \"\") {\r\n\t\t\ttext = this.populateString(text, this.dataItem);\r\n\t\t}\r\n\r\n\t\tif (output == \"html\") {\r\n\t\t\tif (this._adapterO) {\r\n\t\t\t\ttext = this._adapterO.apply(\"htmlOutput\", text);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (this._adapterO) {\r\n\t\t\t\ttext = this._adapterO.apply(\"textOutput\", text);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Update the text\r\n\t\tlet changed = text != this.currentText || output != this._currentFormat;\r\n\t\tthis.currentText = text;\r\n\t\tthis._currentFormat = output;\r\n\r\n\t\treturn changed;\r\n\t}\r\n\r\n\t/**\r\n\t * Hard invalidate means the text will be redrawn even if it hasn't changed.\r\n\t * This is used when we change `fontSize`, `fontFamily`, or for some other\r\n\t * reasons.\r\n\t */\r\n\tpublic hardInvalidate() {\r\n\t\tthis._prevStatus = \"\";\r\n\t\tthis.invalidate();\r\n\t}\r\n\r\n\t/**\r\n\t * Gets line bbox, uses caching to save cpu\r\n\t * @ignore\r\n\t */\r\n\tprotected getLineBBox(lineInfo: ITextLineInfo) {\r\n\t\t//let cacheKey = lineInfo.text + lineInfo.style;\r\n\r\n\t\t//let lineBBox = this.getCache(cacheKey);\r\n\t\t//if (!lineBBox) {\r\n\t\t//lineBBox = lineInfo.element.getBBox();\r\n\t\t//if (lineBBox.width != 0 && lineBBox.height != 0) {\r\n\t\t//\tthis.setCache(cacheKey, lineBBox, 5000);\r\n\t\t//}\r\n\t\t//}\r\n\r\n\t\tlet element = lineInfo && lineInfo.element;\r\n\t\tlet node = element && element.node;\r\n\r\n\t\t// Check for the parent Node to avoid FF from throwing errors\r\n\t\tif (node && node.parentNode) {\r\n\t\t\tlineInfo.bbox = element.getBBox();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Draws the textual label.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic draw(): void {\r\n\r\n\t\t// Draw super\r\n\t\tsuper.draw();\r\n\r\n\t\tlet oldW = this.bbox.width;\r\n\t\tlet oldH = this.bbox.height;\r\n\r\n\t\tlet topParent = this.topParent;\r\n\t\tif (topParent) {\r\n\t\t\tif (!topParent.maxWidth || !topParent.maxHeight) {\r\n\t\t\t\ttopParent.events.once(\"maxsizechanged\", this.hardInvalidate, this, false);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Calculate max width and height\r\n\t\tlet maxWidth: number = $math.max(this.availableWidth - this.pixelPaddingLeft - this.pixelPaddingRight, 0);\r\n\t\tlet maxHeight: number = $math.max(this.availableHeight - this.pixelPaddingTop - this.pixelPaddingBottom, 0);\r\n\r\n\t\t// save\r\n\t\tlet status = maxHeight + \",\" + maxWidth + this.wrap + this.truncate + this.fullWords + this.rtl + this.ellipsis;\r\n\r\n\t\t// Update text\r\n\t\tif (!this.updateCurrentText() && this.inited && this._prevStatus == status) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._measuredWidth = 0;\r\n\t\tthis._measuredHeight = 0;\r\n\r\n\t\t// Reset\r\n\t\tthis.isOversized = false;\r\n\r\n\t\t// Determine output format\r\n\t\tlet output = this._currentFormat;\r\n\t\tlet text = this.currentText;\r\n\r\n\t\t// Empty string\r\n\t\tif (!$type.hasValue(text) || text == \"\") {\r\n\t\t\tthis.element.attr({ display: \"none\" });\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Chop up text into lines\r\n\t\t// We're still processing SVG and HTML in the same way for now\r\n\t\tlet lines: string[] = text.split(\"\\n\");\r\n\r\n\t\t// Do we need to go through the trouble of measuring lines\r\n\t\t//let measure: boolean = true;// (lines.length > 1) || this.wrap;\r\n\r\n\t\tthis._prevStatus = status;\r\n\r\n\t\tthis.textAlign = this.textAlign;\r\n\r\n\t\t// need this to measure\r\n\t\tlet display = this.group.getAttr(\"display\");\r\n\t\tif (display == \"none\") {\r\n\t\t\tthis.group.removeAttr(\"display\");\r\n\t\t}\r\n\r\n\t\tif (this.textPathElement) {\r\n\t\t\tthis.textPathElement.removeChildren();\r\n\t\t}\r\n\r\n\t\t// SVG or HTML?\r\n\t\tif (output === \"svg\") {\r\n\t\t\t/**\r\n\t\t\t * SVG\r\n\t\t\t */\r\n\r\n\t\t\tthis.element.removeAttr(\"display\");\r\n\r\n\t\t\t// Clear the element\r\n\t\t\tlet group: Group = <Group>this.element;\r\n\r\n\t\t\tthis.resetBBox();\r\n\r\n\t\t\t// Init state variables\r\n\t\t\tlet currentHeight: number = 0;\r\n\t\t\tlet currentFormat: string = \"\";\r\n\r\n\t\t\t// Process each line\r\n\t\t\tfor (let i = 0; i < lines.length; i++) {\r\n\r\n\t\t\t\t// Get line\r\n\t\t\t\tlet line: string = lines[i];\r\n\r\n\t\t\t\t// Check if line is empty\r\n\t\t\t\tif (line == \"\") {\r\n\t\t\t\t\t// It is, let's just update currentHeight and go to the next one\r\n\t\t\t\t\t// If it's the first line, we'll have to use arbirary line height,\r\n\t\t\t\t\t// since there's nothing to measure. For subsequent lines we can take\r\n\t\t\t\t\t// previous line's height\r\n\t\t\t\t\tlet tempElement = this.getSVGLineElement(\"\", 0);\r\n\t\t\t\t\ttempElement.add(\r\n\t\t\t\t\t\tthis.getSvgElement(\r\n\t\t\t\t\t\t\t\".\",\r\n\t\t\t\t\t\t\tgetTextFormatter().translateStyleShortcuts(currentFormat)\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\tgroup.add(tempElement);\r\n\t\t\t\t\tlet offset = Math.ceil(tempElement.getBBox().height);\r\n\t\t\t\t\tif (offset > 0) {\r\n\t\t\t\t\t\tcurrentHeight += offset;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tgroup.removeElement(tempElement);\r\n\r\n\t\t\t\t\t// Clear cache if necessary\r\n\t\t\t\t\tlet lineInfo = this.getLineInfo(i);\r\n\t\t\t\t\tif (lineInfo) {\r\n\t\t\t\t\t\tlineInfo.text = \"\";\r\n\t\t\t\t\t\tlineInfo.element.textContent = \"\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Chunk up the line and process each chunk\r\n\t\t\t\tlet chunks: ITextChunk[] = getTextFormatter().chunk(line, null, this.ignoreFormatting);\r\n\t\t\t\tlet currentLineHeight: number = 0;\r\n\t\t\t\tlet firstChunk: boolean = true;\r\n\t\t\t\tlet skipTextChunks: boolean = false;\r\n\r\n\t\t\t\t// Create line element or grab it from cache\r\n\t\t\t\tlet lineInfo = this.getLineInfo(i);\r\n\r\n\t\t\t\tif (lineInfo) {\r\n\t\t\t\t\t// Empty line\r\n\t\t\t\t\tlineInfo.text = \"\";\r\n\t\t\t\t\tlineInfo.element.textContent = \"\";\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// Init new line info\r\n\t\t\t\t\tlineInfo = {\r\n\t\t\t\t\t\t\"text\": \"\",\r\n\t\t\t\t\t\t\"element\": this.getSVGLineElement(\"\", 0),\r\n\t\t\t\t\t\t\"complex\": false\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\t// Create the line element\r\n\t\t\t\t\t//lineInfo.element = this.getSVGLineElement(\"\", 0);\r\n\t\t\t\t\t//lineElement = this.getSVGLineElement(\"\", 0);\r\n\t\t\t\t\tgroup.add(lineInfo.element);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlineInfo.element.removeAttr(\"display\");\r\n\t\t\t\tlineInfo.element.removeChildren(); // memory leak without this\r\n\r\n\t\t\t\tif (this.textPathElement) {\r\n\t\t\t\t\tlineInfo.element.add(this.textPathElement);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/*// @todo not needed anymore\r\n\t\t\t\tif (this.rtl) {\r\n\t\t\t\t\tchunks.reverse();\r\n\t\t\t\t}*/\r\n\r\n\t\t\t\t// Process each chunk\r\n\t\t\t\tfor (let x: number = 0; x < chunks.length; x++) {\r\n\r\n\t\t\t\t\t// If there's more than one chunk, means the line is \"complex\"\r\n\t\t\t\t\tif (x) {\r\n\t\t\t\t\t\tlineInfo.complex = true;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Get chunk\r\n\t\t\t\t\tlet chunk = chunks[x];\r\n\r\n\t\t\t\t\t// Is this chunk format or text?\r\n\t\t\t\t\tif (chunk.type === \"format\") {\r\n\r\n\t\t\t\t\t\t// Log current format, so that we can apply it to multiple lines if\r\n\t\t\t\t\t\t// necessary\r\n\t\t\t\t\t\tcurrentFormat = chunk.text;\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\r\n\t\t\t\t\t\t// It's text block\r\n\r\n\t\t\t\t\t\t// Need to skip?\r\n\t\t\t\t\t\t// We do this when truncating. We can't just simply go ahead and\r\n\t\t\t\t\t\t// abandon chunk processing as they might have formatting\r\n\t\t\t\t\t\t// instructions in them that are relevant for subsequent lines\r\n\t\t\t\t\t\tif (skipTextChunks) {\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Add chunk to the current element\r\n\t\t\t\t\t\t//lineInfo.element.content += $utils.trim(getTextFormatter().format(currentFormat + chunk.text, output));\r\n\r\n\t\t\t\t\t\tlineInfo.text = chunk.text;\r\n\t\t\t\t\t\tlineInfo.style = getTextFormatter().translateStyleShortcuts(currentFormat);\r\n\r\n\r\n\t\t\t\t\t\tlet tspan = this.getSvgElement(lineInfo.text, lineInfo.style);\r\n\r\n\t\t\t\t\t\tif (this.textPathElement) {\r\n\t\t\t\t\t\t\tthis.textPathElement.add(tspan);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tlineInfo.element.add(tspan);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tthis.getLineBBox(lineInfo);\r\n\t\t\t\t\t\tlineInfo.bbox.width = Math.ceil(lineInfo.bbox.width);\r\n\r\n\t\t\t\t\t\t// Updated current line height\r\n\t\t\t\t\t\tif (currentLineHeight < lineInfo.bbox.height) {\r\n\t\t\t\t\t\t\tcurrentLineHeight = lineInfo.bbox.height;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Wrapping?\r\n\t\t\t\t\t\tif ((this.wrap || this.truncate) && (lineInfo.bbox.width > maxWidth)) {\r\n\r\n\t\t\t\t\t\t\t// Set oversized\r\n\t\t\t\t\t\t\tthis.isOversized = true;\r\n\r\n\t\t\t\t\t\t\t// Take temporary measurements\r\n\t\t\t\t\t\t\tlet lineText: string = lineInfo.element.textContent;\r\n\t\t\t\t\t\t\tlet avgCharWidth: number = (lineInfo.bbox.width / lineText.length); // * .9;\r\n\r\n\t\t\t\t\t\t\t// Calculate average number of symbols / width\r\n\t\t\t\t\t\t\tlet excessChars: number = $math.min(Math.ceil((lineInfo.bbox.width - maxWidth) / avgCharWidth), lineText.length);\r\n\r\n\t\t\t\t\t\t\t// Are we truncating or auto-wrapping text?\r\n\t\t\t\t\t\t\tif (this.truncate) {\r\n\r\n\t\t\t\t\t\t\t\t/**\r\n\t\t\t\t\t\t\t\t * Processing line truncation\r\n\t\t\t\t\t\t\t\t * With the addition of each text chunk we measure if current\r\n\t\t\t\t\t\t\t\t * line does not exceed maxWidth. If it does, we will stop\r\n\t\t\t\t\t\t\t\t * addition of further chunks as well as try to truncate\r\n\t\t\t\t\t\t\t\t * current or any number of previous chunks with an added\r\n\t\t\t\t\t\t\t\t * ellipsis\r\n\t\t\t\t\t\t\t\t */\r\n\r\n\t\t\t\t\t\t\t\t// Indicator whether we need to add ellipsis to the current\r\n\t\t\t\t\t\t\t\t// element, even if it fits. This is needed to indicate\r\n\t\t\t\t\t\t\t\t// whether we have already removed some subsequent chunks in\r\n\t\t\t\t\t\t\t\t// which case we need to add ellipsis.\r\n\t\t\t\t\t\t\t\tlet addEllipsis: boolean = false;\r\n\r\n\t\t\t\t\t\t\t\t// Process each child in the temporary line, until the whole\r\n\t\t\t\t\t\t\t\t// line fits, preferably with an ellipsis\r\n\t\t\t\t\t\t\t\t// TODO use iterator instead\r\n\t\t\t\t\t\t\t\tlet node = lineInfo.element.node;\r\n\t\t\t\t\t\t\t\tif (node && node.childNodes) {\r\n\t\t\t\t\t\t\t\t\tfor (let e = lineInfo.element.node.childNodes.length - 1; e >= 0; e--) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Get current element\r\n\t\t\t\t\t\t\t\t\t\tlet node = lineInfo.element.node.childNodes[e];\r\n\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Add ellipsis only if previous chunk was removed in full\r\n\t\t\t\t\t\t\t\t\t\t// and this chunk already fits\r\n\t\t\t\t\t\t\t\t\t\t//if (addEllipsis && (bbox.width <= maxWidth)) {\r\n\t\t\t\t\t\t\t\t\t\tif (addEllipsis && (lineInfo.bbox.width <= maxWidth)) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Add ellipsis\r\n\t\t\t\t\t\t\t\t\t\t\tnode.textContent += \" \" + this.ellipsis;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Measure again (we need to make sure ellipsis fits)\r\n\t\t\t\t\t\t\t\t\t\t\tlineInfo.bbox = lineInfo.element.getBBox();\r\n\t\t\t\t\t\t\t\t\t\t\tlineInfo.bbox.width = Math.floor(lineInfo.bbox.width);\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// If it fits, we're done here\r\n\t\t\t\t\t\t\t\t\t\t\t// If it doesn't we continue rolling\r\n\t\t\t\t\t\t\t\t\t\t\tif (lineInfo.bbox.width <= maxWidth) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\taddEllipsis = false;\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Get element text\r\n\t\t\t\t\t\t\t\t\t\tlet elementText = node.textContent;\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Calculate average number of symbols / width\r\n\t\t\t\t\t\t\t\t\t\tlineText = lineInfo.element.textContent;\r\n\t\t\t\t\t\t\t\t\t\texcessChars = $math.min(Math.ceil((lineInfo.bbox.width - maxWidth) / avgCharWidth), lineText.length);\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Do this until we fit\r\n\t\t\t\t\t\t\t\t\t\twhile ((lineInfo.bbox.width > maxWidth) && (excessChars <= lineText.length) && (excessChars > 0)) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Calculate max available chars\r\n\t\t\t\t\t\t\t\t\t\t\tlet maxChars: number = $math.max(lineText.length - excessChars - this.ellipsis.length, 1);\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Is there anything left?\r\n\t\t\t\t\t\t\t\t\t\t\tif (maxChars <= 1) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Nope, let's jump to the previous item\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Set excess characters to zero so that this loop does\r\n\t\t\t\t\t\t\t\t\t\t\t\t// not repeat when it over\r\n\t\t\t\t\t\t\t\t\t\t\t\texcessChars = 0;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Add ellipsis to previous item\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Subsequent iterations will check if the ellipsis fits\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (e > 0) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t// Indicating to add ellipsis to previous item\r\n\t\t\t\t\t\t\t\t\t\t\t\t\taddEllipsis = true;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t// Removing this node\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tlineInfo.element.node.removeChild(node);\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Truncate the text\r\n\t\t\t\t\t\t\t\t\t\t\telementText = $utils.truncateWithEllipsis(elementText, maxChars, this.ellipsis, this.fullWords, this.rtl);\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tif ((elementText.length > maxChars) && this.fullWords) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Still too long?\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Let's try truncating breaking words anyway\r\n\t\t\t\t\t\t\t\t\t\t\t\telementText = $utils.truncateWithEllipsis(elementText, maxChars, this.ellipsis, false, this.rtl);\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Set truncated text\r\n\t\t\t\t\t\t\t\t\t\t\tnode.textContent = elementText;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Measure again\r\n\t\t\t\t\t\t\t\t\t\t\tlineInfo.bbox = lineInfo.element.getBBox();\r\n\t\t\t\t\t\t\t\t\t\t\tlineInfo.bbox.width = Math.floor(lineInfo.bbox.width);\r\n\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Increase excess characters count, just in case it still\r\n\t\t\t\t\t\t\t\t\t\t\t// doesn't fit and we have to go at it again\r\n\t\t\t\t\t\t\t\t\t\t\texcessChars = Math.ceil(excessChars * 1.1);\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Do not process further chunks\r\n\t\t\t\t\t\t\t\t\t\tskipTextChunks = true;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\r\n\t\t\t\t\t\t\t\t/**\r\n\t\t\t\t\t\t\t\t * Processign auto-wrap\r\n\t\t\t\t\t\t\t\t * In this case we're going to be adding text chunks until\r\n\t\t\t\t\t\t\t\t * they don't fit into current line. Once that happens we will\r\n\t\t\t\t\t\t\t\t * inject the rest of the chunks to the next line\r\n\t\t\t\t\t\t\t\t */\r\n\t\t\t\t\t\t\t\t// Get last node added and measure it\r\n\t\t\t\t\t\t\t\tlet node = lineInfo.element.node;\r\n\t\t\t\t\t\t\t\tif (node) {\r\n\t\t\t\t\t\t\t\t\tlet lastNode = lineInfo.element.node.lastChild;\r\n\r\n\t\t\t\t\t\t\t\t\t// Init split lines\r\n\t\t\t\t\t\t\t\t\tlet splitLines: string[];\r\n\t\t\t\t\t\t\t\t\twhile ((lineInfo.bbox.width > maxWidth) && (excessChars <= lineText.length) && (excessChars > 0)) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Calculate max available chars\r\n\t\t\t\t\t\t\t\t\t\tlet maxChars: number = $math.max(chunk.text.length - excessChars, 1);\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Don't split the words mid-word if it's not the first chunk\r\n\t\t\t\t\t\t\t\t\t\t// in the line\r\n\t\t\t\t\t\t\t\t\t\tif (firstChunk) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Split mid-word if necessary\r\n\t\t\t\t\t\t\t\t\t\t\tsplitLines = $utils.splitTextByCharCount(chunk.text, maxChars, true, this.rtl);\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\telse {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Don't split mid-word\r\n\t\t\t\t\t\t\t\t\t\t\tsplitLines = $utils.splitTextByCharCount(chunk.text, maxChars, true, this.rtl);\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Check if the first word is too long\r\n\t\t\t\t\t\t\t\t\t\t\tif ((splitLines[0].length > maxChars) || maxChars === 1) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Yes - move the whole chunk to the next line\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Remove the element we just added\r\n\t\t\t\t\t\t\t\t\t\t\t\tlineInfo.element.node.removeChild(lastNode)\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Break out of the while on next cycle\r\n\t\t\t\t\t\t\t\t\t\t\t\texcessChars = 0;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Use the first line to update last item\r\n\t\t\t\t\t\t\t\t\t\tif (excessChars > 0) {\r\n\t\t\t\t\t\t\t\t\t\t\tlastNode.textContent = getTextFormatter().cleanUp($utils.trim(splitLines.shift()));\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Measure again, just in case\r\n\t\t\t\t\t\t\t\t\t\tlineInfo.bbox = lineInfo.element.getBBox();\r\n\t\t\t\t\t\t\t\t\t\tlineInfo.bbox.width = Math.floor(lineInfo.bbox.width);\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Increase excess characters count, just in case it still\r\n\t\t\t\t\t\t\t\t\t\t// doesn't fit and we have to go at it again\r\n\t\t\t\t\t\t\t\t\t\t//excessChars = Math.ceil(excessChars * 1.05);\r\n\t\t\t\t\t\t\t\t\t\texcessChars++;\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\t\t\t\t\t// Construct the rest of the line\r\n\t\t\t\t\t\t\t\t\tif (splitLines.length > 0) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tlet restOfLine: string = \"\";\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Add leftovers from splitting the current chunk\r\n\t\t\t\t\t\t\t\t\t\tif ($type.hasValue(splitLines)) {\r\n\t\t\t\t\t\t\t\t\t\t\tif (this.rtl) {\r\n\t\t\t\t\t\t\t\t\t\t\t\trestOfLine += splitLines.join(\"\") + currentFormat;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t\t\t\trestOfLine += currentFormat + splitLines.join(\"\").replace(/([\\[\\]]{1})/g, \"$1$1\");\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Add the rest of the chunks\r\n\t\t\t\t\t\t\t\t\t\tfor (let c: number = x + 1; c < chunks.length; c++) {\r\n\t\t\t\t\t\t\t\t\t\t\tif (chunks[c].type == \"value\") {\r\n\t\t\t\t\t\t\t\t\t\t\t\t// We're escaping single square brackets that were\r\n\t\t\t\t\t\t\t\t\t\t\t\t// cleaned up by chunk() back to double square brackets\r\n\t\t\t\t\t\t\t\t\t\t\t\t// so that they are not being treated as format on\r\n\t\t\t\t\t\t\t\t\t\t\t\t// next pass.\r\n\t\t\t\t\t\t\t\t\t\t\t\trestOfLine += chunks[c].text.replace(/([\\[\\]]{1})/g, \"$1$1\");\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t\t\t\trestOfLine += chunks[c].text;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Inject the rest of the lines as chunks for subsequent\r\n\r\n\t\t\t\t\t\t\t\t\t\tlines.splice(i + 1, 0, restOfLine);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t// Skip processing the rest of the chunks\r\n\t\t\t\t\t\t\t\t\tskipTextChunks = true;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// Let's update the text's bbox with the line's one\r\n\t\t\t\t\t\tif (this.bbox.width < lineInfo.bbox.width) {\r\n\t\t\t\t\t\t\tthis.bbox.width = lineInfo.bbox.width;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// commented to avoid bug (seen on sankey link) where text is incorrectly aligned\r\n\t\t\t\t\t\t//if (this.bbox.x > lineInfo.bbox.x) {\r\n\t\t\t\t\t\t//this.bbox.x = lineInfo.bbox.x;\r\n\t\t\t\t\t\t//}\r\n\r\n\t\t\t\t\t\tthis.bbox.height = currentHeight + currentLineHeight;\r\n\r\n\t\t\t\t\t\t// Position current line\r\n\t\t\t\t\t\tif (!this.textPathElement) {\r\n\t\t\t\t\t\t\tlineInfo.element.attr({\r\n\t\t\t\t\t\t\t\t\"x\": \"0\",\r\n\t\t\t\t\t\t\t\t\"y\": currentHeight + currentLineHeight,\r\n\t\t\t\t\t\t\t\t\"dy\": $math.round((this.baseLineRatio * currentLineHeight), 3).toString()\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tlineInfo.element.attr({\r\n\t\t\t\t\t\t\t\t\"dy\": -this.paddingBottom.toString()\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfirstChunk = false;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Trim the last item\r\n\t\t\t\tlet node = lineInfo.element.node;\r\n\t\t\t\tif (node) {\r\n\t\t\t\t\tlet lastNode = node.lastChild;\r\n\t\t\t\t\tif (lastNode) {\r\n\t\t\t\t\t\tlastNode.textContent = this.rtl ?\r\n\t\t\t\t\t\t\t$utils.ltrim(lastNode.textContent) :\r\n\t\t\t\t\t\t\t$utils.rtrim(lastNode.textContent);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Increment collective height\r\n\t\t\t\tcurrentHeight += currentLineHeight;\r\n\r\n\t\t\t\t// Save line cache\r\n\t\t\t\tthis.addLineInfo(lineInfo, i);\r\n\t\t\t}\r\n\r\n\t\t\t// Check if maybe we need to hide the whole label if it doesn't fit\r\n\t\t\tthis.maybeHideOversized();\r\n\r\n\t\t\tthis.measureFailed = false;\r\n\t\t\tif (this.bbox.width == 0 || this.bbox.height == 0) {\r\n\t\t\t\tthis.measureFailed = true;\r\n\t\t\t}\r\n\r\n\t\t\t// Updated measured dims\r\n\t\t\tthis._measuredWidth = $math.round($math.max(this.bbox.width, this.pixelWidth - this.pixelPaddingLeft - this.pixelPaddingRight));\r\n\t\t\tthis._measuredHeight = $math.round($math.max(this.bbox.height, this.pixelHeight - this.pixelPaddingTop - this.pixelPaddingBottom));\r\n\r\n\t\t\t// Align the lines\r\n\t\t\tthis.alignSVGText();\r\n\r\n\t\t\tthis.bbox.width = this._measuredWidth;\r\n\t\t\tthis.bbox.height = this._measuredHeight;\r\n\r\n\t\t\tif (oldH != this._measuredHeight || oldW != this._measuredWidth) {\r\n\t\t\t\tthis.dispatch(\"transformed\");\r\n\t\t\t}\r\n\r\n\t\t\tthis.hideUnused(lines.length);\r\n\t\t}\r\n\t\telse {\r\n\r\n\t\t\t/**\r\n\t\t\t * HTML\r\n\t\t\t */\r\n\r\n\t\t\tthis.element.removeAttr(\"display\");\r\n\t\t\tthis.resetBBox();\r\n\r\n\t\t\t// Clear the element\r\n\t\t\tlet group: Group = <Group>this.element;\r\n\t\t\tgroup.removeChildren();\r\n\r\n\t\t\t// Create a ForeignObject to use as HTML container\r\n\t\t\tlet fo = this.paper.foreignObject();\r\n\t\t\tgroup.add(fo);\r\n\r\n\t\t\t// Set widths on foreignObject so that autosizing measurements work\r\n\t\t\t// This will bet reset to actual content width/height\r\n\t\t\tif (this.maxWidth) {\r\n\t\t\t\tfo.attr({\r\n\t\t\t\t\twidth: this.maxWidth - this.pixelPaddingLeft - this.pixelPaddingRight\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tif (this.maxHeight) {\r\n\t\t\t\tfo.attr({\r\n\t\t\t\t\theight: this.maxHeight - this.pixelPaddingTop - this.pixelPaddingBottom\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// Create line element\r\n\t\t\t//let lineElement: HTMLElement = this.getHTMLLineElement(getTextFormatter().format(this.html, output));\r\n\t\t\tlet lineElement: HTMLElement = this.getHTMLLineElement(text);\r\n\t\t\tfo.node.appendChild(lineElement);\r\n\r\n\t\t\t// Temporarily set to inline-block so we can measure real width and height\r\n\t\t\tlineElement.style.display = \"inline-block\";\r\n\t\t\tconst clientWidth = lineElement.clientWidth;\r\n\t\t\tconst clientHeight = lineElement.clientHeight;\r\n\r\n\t\t\tlineElement.style.display = \"block\";\r\n\t\t\tthis._bbox = {\r\n\t\t\t\tx: 0,\r\n\t\t\t\ty: 0,\r\n\t\t\t\twidth: clientWidth,\r\n\t\t\t\theight: clientHeight\r\n\t\t\t};\r\n\r\n\t\t\t// Set exact dimensions of foreignObject so it is sized exactly as\r\n\t\t\t// the content within (add one pixel to width so it does not wrap)\r\n\t\t\tfo.attr({\r\n\t\t\t\twidth: clientWidth + 1,\r\n\t\t\t\theight: clientHeight\r\n\t\t\t});\r\n\r\n\t\t\t// Check if maybe we need to hide the whole label if it doesn't fit\r\n\t\t\tthis.maybeHideOversized();\r\n\r\n\t\t\t// Set measurements and update bbox\r\n\t\t\tthis._measuredWidth = $math.max(this.bbox.width, this.pixelWidth - this.pixelPaddingLeft - this.pixelPaddingRight);\r\n\t\t\tthis._measuredHeight = $math.max(this.bbox.height, this.pixelHeight - this.pixelPaddingTop - this.pixelPaddingBottom);\r\n\r\n\t\t\tthis.bbox.width = this._measuredWidth;\r\n\t\t\tthis.bbox.height = this._measuredHeight;\r\n\r\n\t\t\t// Don't let labels bleed out of the alotted area\r\n\t\t\tif (this.truncate) {\r\n\t\t\t\tlineElement.style.overflow = \"hidden\";\r\n\t\t\t}\r\n\r\n\t\t\tif ((clientWidth > maxWidth) || (clientHeight > maxHeight)) {\r\n\t\t\t\tthis.isOversized = true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\t// Set applicable styles\r\n\t\tthis.setStyles();\r\n\t\tthis.updateCenter();\r\n\t\tthis.updateBackground();\r\n\r\n\t\tif (display == \"none\") {\r\n\t\t\tthis.group.attr({ display: \"none\" });\r\n\t\t}\r\n\r\n\t\tif (this.pathElement) {\r\n\t\t\tthis.paper.appendDef(this.pathElement);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Hides element if it does not fit into available space\r\n\t */\r\n\tprivate maybeHideOversized(): void {\r\n\t\tif (this.hideOversized) {\r\n\t\t\tif ((this.availableWidth < this.bbox.width) || (this.availableHeight < this.bbox.height)) {\r\n\t\t\t\tthis.element.attr({ display: \"none\" });\r\n\t\t\t\tthis.isOversized = true;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.element.removeAttr(\"display\");\r\n\t\t\t\tthis.isOversized = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Aligns the lines horizontally ant vertically, based on properties.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic alignSVGText(): void {\r\n\t\t// Get Group\r\n\t\tlet group: Group = <Group>this.element;\r\n\t\tlet children = group.node.children || group.node.childNodes;\r\n\r\n\t\t// Is there anything to align?\r\n\t\tif (!children || (children && children.length == 0)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet width = this._measuredWidth;\r\n\t\tlet height = this._measuredHeight;\r\n\r\n\t\t// TODO maybe these aren't needed ?\r\n\t\t$utils.used(this.pixelPaddingLeft);\r\n\t\t$utils.used(this.pixelPaddingRight);\r\n\t\t$utils.used(this.pixelPaddingTop);\r\n\t\t$utils.used(this.pixelPaddingBottom);\r\n\r\n\t\tif (this.rtl) {\r\n\t\t\tgroup.attr({\r\n\t\t\t\t\"direction\": \"rtl\"\r\n\t\t\t});\r\n\t\t}\r\n\t\telse {\r\n\t\t\tgroup.removeAttr(\"direction\");\r\n\t\t}\r\n\r\n\t\t// Process each line\r\n\t\t//$iter.each(group.children.backwards().iterator(), (element) => {\r\n\t\tfor (let i = children.length - 1; i >= 0; i--) {\r\n\t\t\t// Align horizontally\r\n\t\t\t// Since we are using `text-anchor` for horizontal alignment, all we need\r\n\t\t\t// to do here is move the `x` position\r\n\t\t\tlet node = <SVGElement>children[i];\r\n\r\n\t\t\tnode.setAttribute(\"text-anchor\", this.textAlign);\r\n\r\n\t\t\tif (this.textPathElement) {\r\n\t\t\t\tnode.removeAttribute(\"x\");\r\n\t\t\t\tnode.removeAttribute(\"y\");\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tswitch (this.textAlign) {\r\n\t\t\t\t\tcase \"middle\":\r\n\t\t\t\t\t\tnode.setAttribute(\"x\", (width / 2).toString() + \"px\");\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"end\":\r\n\t\t\t\t\t\tif (this.rtl) {\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tnode.setAttribute(\"x\", width.toString());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tif (this.rtl) {\r\n\t\t\t\t\t\t\tnode.setAttribute(\"x\", width.toString());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tnode.removeAttribute(\"text-anchor\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet y = $type.toNumber(node.getAttribute(\"y\"));\r\n\r\n\t\t\t\tswitch (this.textValign) {\r\n\t\t\t\t\tcase \"middle\":\r\n\t\t\t\t\t\tnode.setAttribute(\"y\", ((y || 0) + (height - this.bbox.height) / 2).toString());\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"bottom\":\r\n\t\t\t\t\t\tnode.setAttribute(\"y\", ((y || 0) + height - this.bbox.height).toString());\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tnode.setAttribute(\"y\", (y || 0).toString());\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Produces an SVG line element with formatted text.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text    Text to wrap into line\r\n\t * @param y       Current line vertical position\r\n\t * @return A DOM element\r\n\t * @todo Implement HTML support\r\n\t */\r\n\tpublic getSVGLineElement(text: string, y?: number): Group {\r\n\r\n\t\t// Create a <text> node and set text\r\n\t\tlet element: Group = this.paper.addGroup(\"text\");\r\n\t\telement.textContent = text;\r\n\r\n\t\t// Set parameters\r\n\t\telement.attr({\r\n\t\t\t\"x\": \"0\"\r\n\t\t\t//\"alignment-baseline\": \"hanging\",\r\n\t\t\t//\"baseline-shift\": \"-20%\",\r\n\t\t\t//\"text-anchor\": \"center\"\r\n\t\t});\r\n\r\n\t\t// Set `y` position\r\n\t\tif ($type.hasValue(y)) {\r\n\t\t\telement.attr({\r\n\t\t\t\t\"y\": y.toString()\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t// Don't let labels blled out of the alotted area\r\n\t\tif (this.truncate || this.wrap) {\r\n\t\t\telement.attr({ \"overflow\": \"hidden\" });\r\n\t\t}\r\n\r\n\t\t// Add RTL?\r\n\t\t// This has now been moved to this.alignSVGText()\r\n\t\t// if (this.rtl) {\r\n\t\t// \telement.attr({\r\n\t\t// \t\t\"direction\": \"rtl\",\r\n\t\t// \t\t//\"unicode-bidi\": \"bidi-override\"\r\n\t\t// \t});\r\n\t\t// }\r\n\r\n\t\treturn element;\r\n\t}\r\n\r\n\t/**\r\n\t * An RTL (right-to-left) setting.\r\n\t *\r\n\t * RTL may affect alignment, text, and other visual properties.\r\n\t *\r\n\t * If you set this on a top-level chart object, it will be used for all\r\n\t * child elements, e.g. labels, unless they have their own `rtl` setting\r\n\t * set directly on them.\r\n\t *\r\n\t * @param value  `true` for to use RTL\r\n\t */\r\n\tpublic set rtl(value: boolean) {\r\n\t\tvalue = $type.toBoolean(value);\r\n\t\tthis._rtl = value;\r\n\t\tif (this.element) {\r\n\t\t\tthis.alignSVGText();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return RTL?\r\n\t */\r\n\tpublic get rtl(): boolean {\r\n\t\tif ($type.hasValue(this._rtl)) {\r\n\t\t\treturn this._rtl;\r\n\t\t}\r\n\t\telse if (this._topParent) {\r\n\t\t\treturn this._topParent.rtl;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * Resets cached BBox.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic resetBBox(): void {\r\n\t\tthis._bbox = { x: 0, y: 0, width: 0, height: 0 };\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Creates and returns an HTML line element (`<div>`).\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text  Text to add\r\n\t * @return `<div>` element reference\r\n\t */\r\n\tpublic getHTMLLineElement(text: string): HTMLElement {\r\n\r\n\t\t// Create the <div> element\r\n\t\tlet div: HTMLElement = document.createElement(\"div\");\r\n\t\tdiv.innerHTML = text;\r\n\r\n\t\t// Set text alignment\r\n\t\tswitch (this.textAlign) {\r\n\t\t\tcase \"middle\":\r\n\t\t\t\tdiv.style.textAlign = \"center\";\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"end\":\r\n\t\t\t\tdiv.style.textAlign = \"right\";\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t// Disable or enable wrapping\r\n\t\tif (this.wrap) {\r\n\t\t\tdiv.style.wordWrap = \"break-word\";\r\n\t\t}\r\n\t\telse {\r\n\t\t\tdiv.style.whiteSpace = \"nowrap\";\r\n\t\t}\r\n\r\n\t\t// Don't let labels bleed out of the alotted area\r\n\t\t// Moved to `draw()` because setting \"hidden\" kills all measuring\r\n\t\t/*if (this.truncate) {\r\n\t\t\tdiv.style.overflow = \"hidden\";\r\n\t\t}*/\r\n\r\n\t\t// Set RTL-related styles\r\n\t\tif (this.rtl) {\r\n\t\t\tdiv.style.direction = \"rtl\";\r\n\t\t\t//div.style.unicodeBidi = \"bidi-override\";\r\n\t\t}\r\n\r\n\t\t// Translate some of the SVG styles into CSS\r\n\t\tif ($type.hasValue(this.fill)) {\r\n\t\t\tdiv.style.color = this.fill.toString();\r\n\t\t}\r\n\r\n\t\treturn div;\r\n\t}\r\n\r\n\t/**\r\n\t * Applies specific styles to text to make it not selectable, unless it is\r\n\t * explicitly set as `selectable`.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Set styles via AMElement\r\n\t */\r\n\tpublic setStyles(): void {\r\n\t\tlet group: Group = <Group>this.element;\r\n\t\tif (!this.selectable || this.draggable || this.resizable || this.swipeable) {\r\n\t\t\tgroup.addStyle({\r\n\t\t\t\t\"webkitUserSelect\": \"none\",\r\n\t\t\t\t\"msUserSelect\": \"none\"\r\n\t\t\t});\r\n\t\t}\r\n\t\telse if (this.selectable) {\r\n\t\t\tgroup.removeStyle(\"webkitUserSelect\");\r\n\t\t\tgroup.removeStyle(\"msUserSelect\");\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Hides unused lines\r\n\t */\r\n\tprotected hideUnused(index: number) {\r\n\t\tthis.initLineCache();\r\n\t\tlet lines: ITextLineInfo[] = this.getCache(\"lineInfo\");\r\n\t\tif (lines.length >= index) {\r\n\t\t\tfor (let i = index; i < lines.length; i++) {\r\n\t\t\t\tlet line = lines[i];\r\n\t\t\t\tif (line && line.element) {\r\n\t\t\t\t\tline.element.attr({ \"display\": \"none\" });\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * An SVG text.\r\n\t *\r\n\t * Please note that setting `html` will override this setting if browser\r\n\t * supports `foreignObject` in SGV, such as most modern browsers excluding\r\n\t * IEs.\r\n\t *\r\n\t * @param value  SVG Text\r\n\t */\r\n\tpublic set text(value: string) {\r\n\t\t//this.setPropertyValue(\"html\", undefined);\r\n\t\tthis.setPropertyValue(\"text\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return SVG text\r\n\t */\r\n\tpublic get text(): string {\r\n\t\treturn this.getPropertyValue(\"text\");\r\n\t}\r\n\r\n\t/**\r\n\t * An SVG path string to position text along. If set, the text will follow\r\n\t * the curvature of the path.\r\n\t *\r\n\t * Location along the path can be set using `locationOnPath`.\r\n\t *\r\n\t * IMPORTANT: Only SVG text can be put on path. If you are using HTML text\r\n\t * this setting will be ignored.\r\n\t *\r\n\t * @since 4.1.2\r\n\t * @param  value  Path\r\n\t */\r\n\tpublic set path(value: string) {\r\n\t\tif (this.setPropertyValue(\"path\", value, true)) {\r\n\t\t\tif (this.pathElement) {\r\n\t\t\t\tthis.pathElement.dispose();\r\n\t\t\t}\r\n\r\n\t\t\tif (this.textPathElement) {\r\n\t\t\t\tthis.textPathElement.dispose();\r\n\t\t\t}\r\n\r\n\t\t\tthis.pathElement = this.paper.add(\"path\");\r\n\t\t\tthis.pathElement.attr({ \"d\": value });\r\n\t\t\tthis.pathElement.attr({ \"id\": \"text-path-\" + this.uid });\r\n\t\t\tthis._disposers.push(this.pathElement);\r\n\r\n\t\t\tthis.textPathElement = this.paper.addGroup(\"textPath\");\r\n\t\t\tthis.textPathElement.attrNS($dom.XLINK, \"xlink:href\", \"#text-path-\" + this.uid);\r\n\t\t\t// TODO remove after https://bugzilla.mozilla.org/show_bug.cgi?id=455986 is fixed\r\n\t\t\tthis.textPathElement.attr({ \"path\": value });\r\n\t\t\tthis._disposers.push(this.textPathElement);\r\n\t\t\tthis.hardInvalidate();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Path\r\n\t */\r\n\tpublic get path(): string {\r\n\t\treturn this.getPropertyValue(\"path\");\r\n\t}\r\n\r\n\t/**\r\n\t * Relative label location on `path`. Value range is from 0 (beginning)\r\n\t * to 1 (end).\r\n\t *\r\n\t * Works only if you set `path` setting to an SVG path.\r\n\t *\r\n\t * @since 4.1.2\r\n\t * @default 0\r\n\t * @param  value  Relatvie location on path\r\n\t */\r\n\tpublic set locationOnPath(value: number) {\r\n\t\tthis.setPropertyValue(\"locationOnPath\", value);\r\n\t\tif (this.textPathElement) {\r\n\t\t\tthis.textPathElement.attr({ \"startOffset\": (value * 100) + \"%\" })\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Relatvie location on path\r\n\t */\r\n\tpublic get locationOnPath(): number {\r\n\t\treturn this.getPropertyValue(\"locationOnPath\");\r\n\t}\r\n\r\n\t/**\r\n\t * A ratio to calculate text baseline. Ralative distance from the bottom of\r\n\t * the label.\r\n\t *\r\n\t * @since 4.4.2\r\n\t * @default -0.27\r\n\t * @param  value  Base line ratio\r\n\t */\r\n\tpublic set baseLineRatio(value: number) {\r\n\t\tthis.setPropertyValue(\"baseLineRatio\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Base line ratio\r\n\t */\r\n\tpublic get baseLineRatio(): number {\r\n\t\treturn this.getPropertyValue(\"baseLineRatio\");\r\n\t}\r\n\r\n\t/**\r\n\t * Enables or disables autowrapping of text.\r\n\t *\r\n\t * @param value  Auto-wrapping enabled\r\n\t */\r\n\tpublic set wrap(value: boolean) {\r\n\t\tthis.resetBBox();\r\n\t\tthis.setPropertyValue(\"wrap\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Auto-wrap enabled or not\r\n\t */\r\n\tpublic get wrap(): boolean {\r\n\t\treturn this.getPropertyValue(\"wrap\");\r\n\t}\r\n\r\n\t/**\r\n\t * Indicates if text lines need to be truncated if they do not fit, using\r\n\t * configurable `ellipsis` string.\r\n\t *\r\n\t * `truncate` overrides `wrap` if both are set to `true`.\r\n\t *\r\n\t * NOTE: For HTML text, this setting **won't** trigger a parser and actual\r\n\t * line truncation with ellipsis. It will just hide everything that goes\r\n\t * outside the label.\r\n\t *\r\n\t * @param value  trincate text?\r\n\t */\r\n\tpublic set truncate(value: boolean) {\r\n\t\tthis.resetBBox();\r\n\t\tthis.setPropertyValue(\"truncate\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Truncate text?\r\n\t */\r\n\tpublic get truncate(): boolean {\r\n\t\treturn this.getPropertyValue(\"truncate\");\r\n\t}\r\n\r\n\t/**\r\n\t * If `truncate` is enabled, should Label try to break only on full words\r\n\t * (`true`), or whenever needed, including middle of the word. (`false`)\r\n\t *\r\n\t * @default true\r\n\t * @param value  Truncate on full words?\r\n\t */\r\n\tpublic set fullWords(value: boolean) {\r\n\t\tthis.setPropertyValue(\"fullWords\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Truncate on full words?\r\n\t */\r\n\tpublic get fullWords(): boolean {\r\n\t\treturn this.getPropertyValue(\"fullWords\");\r\n\t}\r\n\r\n\t/**\r\n\t * Ellipsis character to use if `truncate` is enabled.\r\n\t *\r\n\t * @param value Ellipsis string\r\n\t * @default \"...\"\r\n\t */\r\n\tpublic set ellipsis(value: string) {\r\n\t\tthis.setPropertyValue(\"ellipsis\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Ellipsis string\r\n\t */\r\n\tpublic get ellipsis(): string {\r\n\t\treturn this.getPropertyValue(\"ellipsis\");\r\n\t}\r\n\r\n\t/**\r\n\t * Forces the text to be selectable. This setting will be ignored if the\r\n\t * object has some kind of interaction attached to it, such as it is\r\n\t * `draggable`, `swipeable`, `resizable`.\r\n\t *\r\n\t * @param value  Text selectable?\r\n\t * @default false\r\n\t */\r\n\tpublic set selectable(value: boolean) {\r\n\t\tthis.setPropertyValue(\"selectable\", value, true);\r\n\t\tthis.setStyles();\r\n\t}\r\n\r\n\t/**\r\n\t * @return Text selectable?\r\n\t */\r\n\tpublic get selectable(): boolean {\r\n\t\treturn this.getPropertyValue(\"selectable\");\r\n\t}\r\n\r\n\t/**\r\n\t * Horizontal text alignment.\r\n\t *\r\n\t * Available choices:\r\n\t * * \"start\"\r\n\t * * \"middle\"\r\n\t * * \"end\"\r\n\t *\r\n\t * @param value  Alignment\r\n\t */\r\n\tpublic set textAlign(value: TextAlign) {\r\n\t\tthis.setPropertyValue(\"textAlign\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Alignment\r\n\t */\r\n\tpublic get textAlign(): TextAlign {\r\n\t\treturn this.getPropertyValue(\"textAlign\");\r\n\t}\r\n\r\n\t/**\r\n\t * Vertical text alignment.\r\n\t *\r\n\t * @ignore Exclude from docs (not used)\r\n\t * @param value  Alignment\r\n\t * @deprecated\r\n\t */\r\n\tpublic set textValign(value: TextValign) {\r\n\t\tthis.setPropertyValue(\"textValign\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore Exclude from docs (not used)\r\n\t * @return Alignment\r\n\t * @deprecated\r\n\t */\r\n\tpublic get textValign(): TextValign {\r\n\t\treturn this.getPropertyValue(\"textValign\");\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Raw HTML to be used as text.\r\n\t *\r\n\t * NOTE: HTML text is subject to browser support. It relies on browsers\r\n\t * supporting SVG `foreignObject` nodes. Some browsers (read IEs) do not\r\n\t * support it. On those browsers, the text will fall back to basic SVG text,\r\n\t * striping out all HTML markup and styling that goes with it.\r\n\t *\r\n\t * For more information about `foreignObject` and its browser compatibility\r\n\t * refer to [this page](https://developer.mozilla.org/en/docs/Web/SVG/Element/foreignObject#Browser_compatibility).\r\n\t *\r\n\t * @param value HTML text\r\n\t */\r\n\tpublic set html(value: string) {\r\n\t\tthis.setPropertyValue(\"html\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return HTML content\r\n\t */\r\n\tpublic get html(): string {\r\n\t\treturn this.getPropertyValue(\"html\");\r\n\t}\r\n\r\n\t/**\r\n\t * Indicates whether the whole text should be hidden if it does not fit into\r\n\t * its allotted space.\r\n\t *\r\n\t * @param value  Hide if text does not fit?\r\n\t */\r\n\tpublic set hideOversized(value: boolean) {\r\n\t\tthis.setPropertyValue(\"hideOversized\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Hide if text does not fit?\r\n\t */\r\n\tpublic get hideOversized(): boolean {\r\n\t\treturn this.getPropertyValue(\"hideOversized\");\r\n\t}\r\n\r\n\t/**\r\n\t * If set to `true` square-bracket formatting blocks will be treated as\r\n\t * regular text.\r\n\t *\r\n\t * @default false\r\n\t * @param value  Ignore formatting?\r\n\t */\r\n\tpublic set ignoreFormatting(value: boolean) {\r\n\t\tthis.setPropertyValue(\"ignoreFormatting\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Ignore formatting?\r\n\t */\r\n\tpublic get ignoreFormatting(): boolean {\r\n\t\treturn this.getPropertyValue(\"ignoreFormatting\");\r\n\t}\r\n\r\n\t/**\r\n\t * Override `mesaureElement` so it does not get measure again, because\r\n\t * internal `_bbox` is being updated by measuring routines in Text itself.\r\n\t */\r\n\tpublic measureElement(): void { }\r\n\r\n\t/**\r\n\t * Returns information about a line element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param index  Line index\r\n\t * @return Line info object\r\n\t */\r\n\tpublic getLineInfo(index: number): ITextLineInfo {\r\n\t\tthis.initLineCache();\r\n\t\tlet lines = this.getCache(\"lineInfo\");\r\n\t\treturn lines.length > index ? lines[index] : undefined;\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a line to line info cache.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param line     Line info object\r\n\t * @param index    Insert at specified index\r\n\t */\r\n\tpublic addLineInfo(line: ITextLineInfo, index: number): void {\r\n\t\tthis.initLineCache();\r\n\t\tthis.getCache(\"lineInfo\")[index] = line;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if line cache is initialized and initializes it.\r\n\t */\r\n\tprivate initLineCache(): void {\r\n\t\tif (!$type.hasValue(this.getCache(\"lineInfo\"))) {\r\n\t\t\tthis.setCache(\"lineInfo\", [], 0);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Sets a [[DataItem]] to use for populating dynamic sections of the text.\r\n\t *\r\n\t * Check the description for [[Text]] class, for data binding.\r\n\t *\r\n\t * @param dataItem Data item\r\n\t */\r\n\tpublic setDataItem(dataItem: DataItem): void {\r\n\t\tif (this._sourceDataItemEvents) {\r\n\t\t\tthis._sourceDataItemEvents.dispose();\r\n\t\t}\r\n\t\tif (dataItem) {\r\n\t\t\tthis._sourceDataItemEvents = new MultiDisposer([\r\n\t\t\t\tdataItem.events.on(\"valuechanged\", this.invalidate, this, false),\r\n\t\t\t\tdataItem.events.on(\"workingvaluechanged\", this.invalidate, this, false),\r\n\t\t\t\tdataItem.events.on(\"calculatedvaluechanged\", this.invalidate, this, false),\r\n\t\t\t\tdataItem.events.on(\"propertychanged\", this.invalidate, this, false)\r\n\t\t\t]);\r\n\t\t}\r\n\t\tsuper.setDataItem(dataItem);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns available horizontal space.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @return Available width (px)\r\n\t */\r\n\tpublic get availableWidth(): number {\r\n\t\treturn $type.hasValue(this.maxWidth) ? this.maxWidth : this.pixelWidth;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns available vertical space.\r\n\t *\r\n\t * @return Available height (px)\r\n\t */\r\n\tpublic get availableHeight(): number {\r\n\t\treturn $type.hasValue(this.maxHeight) ? this.maxHeight : this.pixelHeight;\r\n\t}\r\n\r\n\t// temp, replacing textFormatter method\r\n\tpublic getSvgElement(text: string, style?: string): AMElement {\r\n\t\tlet element = this.paper.add(\"tspan\");\r\n\t\telement.textContent = text;\r\n\t\tif (style) {\r\n\t\t\telement.node.setAttribute(\"style\", style);\r\n\t\t}\r\n\t\treturn element;\r\n\t}\r\n\r\n\t/**\r\n\t * Invalidates the whole element, including layout AND all its child\r\n\t * elements.\r\n\t */\r\n\tpublic deepInvalidate() {\r\n\t\tsuper.deepInvalidate();\r\n\t\tthis.hardInvalidate();\r\n\t}\r\n\r\n\t/**\r\n\t * Screen reader title of the element.\r\n\t *\r\n\t * @param value Title\r\n\t */\r\n\tpublic set readerTitle(value: string) {\r\n\t\tvalue = $type.toText(value);\r\n\t\tif (this.setPropertyValue(\"readerTitle\", value)) {\r\n\t\t\tthis.applyAccessibility();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Title\r\n\t */\r\n\tpublic get readerTitle(): string {\r\n\t\tlet title = this.getPropertyValue(\"readerTitle\");\r\n\t\tif (!title) {\r\n\t\t\ttitle = this.populateString(\r\n\t\t\t\t$utils.plainText(\r\n\t\t\t\t\t$utils.isNotEmpty(this.html)\r\n\t\t\t\t\t\t? this.html\r\n\t\t\t\t\t\t: this.text\r\n\t\t\t\t)\r\n\t\t\t);\r\n\t\t}\r\n\t\telse if (this.dataItem) {\r\n\t\t\ttitle = this.populateString(title);\r\n\t\t}\r\n\t\treturn title;\r\n\t}\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"Label\"] = Label;\r\n\r\n/**\r\n * Add default responsive rules\r\n */\r\n\r\n/**\r\n * Hide labels added directly to chart, like titles if chart is short.\r\n */\r\ndefaultRules.push({\r\n\trelevant: ResponsiveBreakpoints.heightXS,\r\n\tstate: function(target, stateId) {\r\n\t\tif (target instanceof Label && target.parent && target.parent.isBaseSprite) {\r\n\t\t\tlet state = target.states.create(stateId);\r\n\t\t\tstate.properties.disabled = true;\r\n\t\t\treturn state;\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t}\r\n});\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}