{"ast":null,"code":"import { isOperatorNode } from '../../../utils/is.js';\nimport { factory } from '../../../utils/factory.js';\nimport { hasOwnProperty } from '../../../utils/object.js';\nvar name = 'simplifyUtil';\nvar dependencies = ['FunctionNode', 'OperatorNode', 'SymbolNode'];\nexport var createUtil = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    FunctionNode,\n    OperatorNode,\n    SymbolNode\n  } = _ref; // TODO commutative/associative properties rely on the arguments\n  // e.g. multiply is not commutative for matrices\n  // The properties should be calculated from an argument to simplify, or possibly something in math.config\n  // the other option is for typed() to specify a return type so that we can evaluate the type of arguments\n\n  var commutative = {\n    add: true,\n    multiply: true\n  };\n  var associative = {\n    add: true,\n    multiply: true\n  };\n\n  function isCommutative(node, context) {\n    if (!isOperatorNode(node)) {\n      return true;\n    }\n\n    var name = node.fn.toString();\n\n    if (context && hasOwnProperty(context, name) && hasOwnProperty(context[name], 'commutative')) {\n      return context[name].commutative;\n    }\n\n    return commutative[name] || false;\n  }\n\n  function isAssociative(node, context) {\n    if (!isOperatorNode(node)) {\n      return false;\n    }\n\n    var name = node.fn.toString();\n\n    if (context && hasOwnProperty(context, name) && hasOwnProperty(context[name], 'associative')) {\n      return context[name].associative;\n    }\n\n    return associative[name] || false;\n  }\n  /**\n   * Flatten all associative operators in an expression tree.\n   * Assumes parentheses have already been removed.\n   */\n\n\n  function flatten(node) {\n    if (!node.args || node.args.length === 0) {\n      return node;\n    }\n\n    node.args = allChildren(node);\n\n    for (var i = 0; i < node.args.length; i++) {\n      flatten(node.args[i]);\n    }\n  }\n  /**\n   * Get the children of a node as if it has been flattened.\n   * TODO implement for FunctionNodes\n   */\n\n\n  function allChildren(node) {\n    var op;\n    var children = [];\n\n    var findChildren = function findChildren(node) {\n      for (var i = 0; i < node.args.length; i++) {\n        var child = node.args[i];\n\n        if (isOperatorNode(child) && op === child.op) {\n          findChildren(child);\n        } else {\n          children.push(child);\n        }\n      }\n    };\n\n    if (isAssociative(node)) {\n      op = node.op;\n      findChildren(node);\n      return children;\n    } else {\n      return node.args;\n    }\n  }\n  /**\n   *  Unflatten all flattened operators to a right-heavy binary tree.\n   */\n\n\n  function unflattenr(node) {\n    if (!node.args || node.args.length === 0) {\n      return;\n    }\n\n    var makeNode = createMakeNodeFunction(node);\n    var l = node.args.length;\n\n    for (var i = 0; i < l; i++) {\n      unflattenr(node.args[i]);\n    }\n\n    if (l > 2 && isAssociative(node)) {\n      var curnode = node.args.pop();\n\n      while (node.args.length > 0) {\n        curnode = makeNode([node.args.pop(), curnode]);\n      }\n\n      node.args = curnode.args;\n    }\n  }\n  /**\n   *  Unflatten all flattened operators to a left-heavy binary tree.\n   */\n\n\n  function unflattenl(node) {\n    if (!node.args || node.args.length === 0) {\n      return;\n    }\n\n    var makeNode = createMakeNodeFunction(node);\n    var l = node.args.length;\n\n    for (var i = 0; i < l; i++) {\n      unflattenl(node.args[i]);\n    }\n\n    if (l > 2 && isAssociative(node)) {\n      var curnode = node.args.shift();\n\n      while (node.args.length > 0) {\n        curnode = makeNode([curnode, node.args.shift()]);\n      }\n\n      node.args = curnode.args;\n    }\n  }\n\n  function createMakeNodeFunction(node) {\n    if (isOperatorNode(node)) {\n      return function (args) {\n        try {\n          return new OperatorNode(node.op, node.fn, args, node.implicit);\n        } catch (err) {\n          console.error(err);\n          return [];\n        }\n      };\n    } else {\n      return function (args) {\n        return new FunctionNode(new SymbolNode(node.name), args);\n      };\n    }\n  }\n\n  return {\n    createMakeNodeFunction,\n    isCommutative,\n    isAssociative,\n    flatten,\n    allChildren,\n    unflattenr,\n    unflattenl\n  };\n});","map":{"version":3,"names":["isOperatorNode","factory","hasOwnProperty","name","dependencies","createUtil","_ref","FunctionNode","OperatorNode","SymbolNode","commutative","add","multiply","associative","isCommutative","node","context","fn","toString","isAssociative","flatten","args","length","allChildren","i","op","children","findChildren","child","push","unflattenr","makeNode","createMakeNodeFunction","l","curnode","pop","unflattenl","shift","implicit","err","console","error"],"sources":["C:/Users/never/OneDrive/เดสก์ท็อป/Numerproject-main/node_modules/mathjs/lib/esm/function/algebra/simplify/util.js"],"sourcesContent":["import { isOperatorNode } from '../../../utils/is.js';\nimport { factory } from '../../../utils/factory.js';\nimport { hasOwnProperty } from '../../../utils/object.js';\nvar name = 'simplifyUtil';\nvar dependencies = ['FunctionNode', 'OperatorNode', 'SymbolNode'];\nexport var createUtil = /* #__PURE__ */factory(name, dependencies, (_ref) => {\n  var {\n    FunctionNode,\n    OperatorNode,\n    SymbolNode\n  } = _ref;\n  // TODO commutative/associative properties rely on the arguments\n  // e.g. multiply is not commutative for matrices\n  // The properties should be calculated from an argument to simplify, or possibly something in math.config\n  // the other option is for typed() to specify a return type so that we can evaluate the type of arguments\n  var commutative = {\n    add: true,\n    multiply: true\n  };\n  var associative = {\n    add: true,\n    multiply: true\n  };\n\n  function isCommutative(node, context) {\n    if (!isOperatorNode(node)) {\n      return true;\n    }\n\n    var name = node.fn.toString();\n\n    if (context && hasOwnProperty(context, name) && hasOwnProperty(context[name], 'commutative')) {\n      return context[name].commutative;\n    }\n\n    return commutative[name] || false;\n  }\n\n  function isAssociative(node, context) {\n    if (!isOperatorNode(node)) {\n      return false;\n    }\n\n    var name = node.fn.toString();\n\n    if (context && hasOwnProperty(context, name) && hasOwnProperty(context[name], 'associative')) {\n      return context[name].associative;\n    }\n\n    return associative[name] || false;\n  }\n  /**\n   * Flatten all associative operators in an expression tree.\n   * Assumes parentheses have already been removed.\n   */\n\n\n  function flatten(node) {\n    if (!node.args || node.args.length === 0) {\n      return node;\n    }\n\n    node.args = allChildren(node);\n\n    for (var i = 0; i < node.args.length; i++) {\n      flatten(node.args[i]);\n    }\n  }\n  /**\n   * Get the children of a node as if it has been flattened.\n   * TODO implement for FunctionNodes\n   */\n\n\n  function allChildren(node) {\n    var op;\n    var children = [];\n\n    var findChildren = function findChildren(node) {\n      for (var i = 0; i < node.args.length; i++) {\n        var child = node.args[i];\n\n        if (isOperatorNode(child) && op === child.op) {\n          findChildren(child);\n        } else {\n          children.push(child);\n        }\n      }\n    };\n\n    if (isAssociative(node)) {\n      op = node.op;\n      findChildren(node);\n      return children;\n    } else {\n      return node.args;\n    }\n  }\n  /**\n   *  Unflatten all flattened operators to a right-heavy binary tree.\n   */\n\n\n  function unflattenr(node) {\n    if (!node.args || node.args.length === 0) {\n      return;\n    }\n\n    var makeNode = createMakeNodeFunction(node);\n    var l = node.args.length;\n\n    for (var i = 0; i < l; i++) {\n      unflattenr(node.args[i]);\n    }\n\n    if (l > 2 && isAssociative(node)) {\n      var curnode = node.args.pop();\n\n      while (node.args.length > 0) {\n        curnode = makeNode([node.args.pop(), curnode]);\n      }\n\n      node.args = curnode.args;\n    }\n  }\n  /**\n   *  Unflatten all flattened operators to a left-heavy binary tree.\n   */\n\n\n  function unflattenl(node) {\n    if (!node.args || node.args.length === 0) {\n      return;\n    }\n\n    var makeNode = createMakeNodeFunction(node);\n    var l = node.args.length;\n\n    for (var i = 0; i < l; i++) {\n      unflattenl(node.args[i]);\n    }\n\n    if (l > 2 && isAssociative(node)) {\n      var curnode = node.args.shift();\n\n      while (node.args.length > 0) {\n        curnode = makeNode([curnode, node.args.shift()]);\n      }\n\n      node.args = curnode.args;\n    }\n  }\n\n  function createMakeNodeFunction(node) {\n    if (isOperatorNode(node)) {\n      return function (args) {\n        try {\n          return new OperatorNode(node.op, node.fn, args, node.implicit);\n        } catch (err) {\n          console.error(err);\n          return [];\n        }\n      };\n    } else {\n      return function (args) {\n        return new FunctionNode(new SymbolNode(node.name), args);\n      };\n    }\n  }\n\n  return {\n    createMakeNodeFunction,\n    isCommutative,\n    isAssociative,\n    flatten,\n    allChildren,\n    unflattenr,\n    unflattenl\n  };\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}