{"ast":null,"code":"/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { Dictionary } from \"./Dictionary\";\nimport * as $type from \"./Type\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Represents object cache.\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Better storage\r\n * @todo TTL logging\r\n * @todo Garbage collector\r\n */\n\nvar Cache =\n/** @class */\nfunction () {\n  function Cache() {\n    /**\r\n     * Storage for cache items.\r\n     */\n    this._storage = new Dictionary();\n    /**\r\n     * Default TTL in milliseconds.\r\n     */\n\n    this.ttl = 1000;\n  }\n  /**\r\n   * Caches or updates cached value, resets TTL.\r\n   *\r\n   * If `ttl` is set to zero, item will never expire.\r\n   *\r\n   * @param owner  An id of the object that owns this cache\r\n   * @param key    Index key\r\n   * @param value  Value\r\n   * @param ttl    TTL of the cache to live in milliseconds\r\n   */\n\n\n  Cache.prototype.set = function (owner, key, value, ttl) {\n    // Create if storage does not exist for this owner\n    var ownerStorage = this._storage.insertKeyIfEmpty(owner, function () {\n      return new Dictionary();\n    }); // Create cache item\n\n\n    var item = {\n      \"touched\": new Date().getTime(),\n      \"ttl\": $type.isNumber(ttl) ? ttl : this.ttl,\n      \"value\": value\n    }; // Set\n\n    ownerStorage.setKey(key, item);\n  };\n  /**\r\n   * Rerturns cached item, respecting TTL.\r\n   *\r\n   * @param owner  An id of the object that owns this cache\r\n   * @param key    Index key\r\n   * @param value  Value to return if cache not available\r\n   * @return Value, or `undefined` if not set\r\n   */\n\n\n  Cache.prototype.get = function (owner, key, value) {\n    if (value === void 0) {\n      value = undefined;\n    } // \t\t || ypeof this._storage[owner][key] === \"undefined\" || this._storage[owner][key].expired === true) {\n\n\n    if (this._storage.hasKey(owner)) {\n      var ownerStorage = this._storage.getKey(owner);\n\n      if (ownerStorage.hasKey(key)) {\n        var cacheItem = ownerStorage.getKey(key);\n\n        if (cacheItem.ttl && cacheItem.touched + cacheItem.ttl < new Date().getTime()) {\n          cacheItem.expired = true;\n        }\n\n        if (cacheItem.expired) {\n          ownerStorage.removeKey(key);\n          return value;\n        }\n\n        return cacheItem.value;\n      } else {\n        return value;\n      }\n    } else {\n      return value;\n    }\n  };\n  /**\r\n   * Clears cache for specific owner or everything.\r\n   *\r\n   * @param owner Owner to clear cache for\r\n   */\n\n\n  Cache.prototype.clear = function (owner) {\n    if (owner) {\n      this._storage.removeKey(owner);\n    } else {\n      this._storage.clear();\n    }\n  };\n\n  return Cache;\n}();\n\nexport { Cache };\n/**\r\n * ============================================================================\r\n * GLOBAL INSTANCE\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * A global instance of cache. Use this instance to cache any values.\r\n *\r\n * @ignore Exclude from docs\r\n */\n\nexport var cache = new Cache();","map":{"version":3,"sources":["../../../../../src/.internal/core/utils/Cache.ts"],"names":[],"mappings":"AAAA;;;;;AAKG;AACH,SAAS,UAAT,QAA2B,cAA3B;AACA,OAAO,KAAK,KAAZ,MAAuB,QAAvB;AAwCA;;;;;AAKG;;AAEH;;;;;;;AAOG;;AACH,IAAA,KAAA;AAAA;AAAA,YAAA;EAAA,SAAA,KAAA,GAAA;IAEC;;AAEG;IACK,KAAA,QAAA,GAAW,IAAI,UAAJ,EAAX;IAER;;AAEG;;IACI,KAAA,GAAA,GAAc,IAAd;EA2EP;EAzEA;;;;;;;;;AASG;;;EACI,KAAA,CAAA,SAAA,CAAA,GAAA,GAAP,UAAW,KAAX,EAA0B,GAA1B,EAAuC,KAAvC,EAAiD,GAAjD,EAA6D;IAE5D;IACA,IAAI,YAAY,GAAG,KAAK,QAAL,CAAc,gBAAd,CAA+B,KAA/B,EAAsC,YAAA;MAAM,OAAA,IAAA,UAAA,EAAA;IAAsC,CAAlF,CAAnB,CAH4D,CAK5D;;;IACA,IAAI,IAAI,GAAiB;MACxB,WAAW,IAAI,IAAJ,GAAW,OAAX,EADa;MAExB,OAAO,KAAK,CAAC,QAAN,CAAe,GAAf,IAAsB,GAAtB,GAA4B,KAAK,GAFhB;MAGxB,SAAS;IAHe,CAAzB,CAN4D,CAY5D;;IACA,YAAY,CAAC,MAAb,CAAoB,GAApB,EAAyB,IAAzB;EACA,CAdM;EAgBP;;;;;;;AAOG;;;EACI,KAAA,CAAA,SAAA,CAAA,GAAA,GAAP,UAAW,KAAX,EAA0B,GAA1B,EAAuC,KAAvC,EAA6D;IAAtB,IAAA,KAAA,KAAA,KAAA,CAAA,EAAA;MAAA,KAAA,GAAA,SAAA;IAAsB,CAAA,CAC5D;;;IACA,IAAI,KAAK,QAAL,CAAc,MAAd,CAAqB,KAArB,CAAJ,EAAiC;MAChC,IAAI,YAAY,GAAqC,KAAK,QAAL,CAAc,MAAd,CAAqB,KAArB,CAArD;;MAEA,IAAI,YAAY,CAAC,MAAb,CAAoB,GAApB,CAAJ,EAA8B;QAC7B,IAAI,SAAS,GAA+B,YAAY,CAAC,MAAb,CAAoB,GAApB,CAA5C;;QACA,IAAI,SAAS,CAAC,GAAV,IAAmB,SAAS,CAAC,OAAV,GAAoB,SAAS,CAAC,GAA/B,GAAsC,IAAI,IAAJ,GAAW,OAAX,EAA5D,EAAmF;UAClF,SAAS,CAAC,OAAV,GAAoB,IAApB;QACA;;QACD,IAAI,SAAS,CAAC,OAAd,EAAuB;UACtB,YAAY,CAAC,SAAb,CAAuB,GAAvB;UACA,OAAO,KAAP;QACA;;QACD,OAAO,SAAS,CAAC,KAAjB;MACA,CAVD,MAWK;QACJ,OAAO,KAAP;MACA;IACD,CAjBD,MAkBK;MACJ,OAAO,KAAP;IACA;EACD,CAvBM;EAyBP;;;;AAIG;;;EACI,KAAA,CAAA,SAAA,CAAA,KAAA,GAAP,UAAa,KAAb,EAA2B;IAC1B,IAAI,KAAJ,EAAW;MACV,KAAK,QAAL,CAAc,SAAd,CAAwB,KAAxB;IACA,CAFD,MAGK;MACJ,KAAK,QAAL,CAAc,KAAd;IACA;EACD,CAPM;;EASR,OAAA,KAAA;AAAC,CArFD,EAAA;;;AAuFA;;;;;AAKG;;AAEH;;;;AAIG;;AACH,OAAO,IAAI,KAAK,GAAe,IAAI,KAAJ,EAAxB","sourcesContent":["/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Dictionary } from \"./Dictionary\";\r\nimport * as $type from \"./Type\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines an interface for cache items.\r\n */\r\ninterface CacheItem<A> {\r\n\r\n\t/**\r\n\t * A timestamp of when the item was created/updated.\r\n\t */\r\n\t\"touched\": number,\r\n\r\n\t/**\r\n\t * TTL (time to live) in milliseconds.\r\n\t */\r\n\t\"ttl\"?: number,\r\n\r\n\t/**\r\n\t * Cached value.\r\n\t */\r\n\t\"value\": A,\r\n\r\n\t/**\r\n\t * Is this item expired?\r\n\t *\r\n\t * @todo a system process that would check chace element TTLs and expire them\r\n\t */\r\n\t\"expired\"?: boolean\r\n\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Represents object cache.\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Better storage\r\n * @todo TTL logging\r\n * @todo Garbage collector\r\n */\r\nexport class Cache<A> {\r\n\r\n\t/**\r\n\t * Storage for cache items.\r\n\t */\r\n\tprivate _storage = new Dictionary<string, Dictionary<string, CacheItem<A>>>();\r\n\r\n\t/**\r\n\t * Default TTL in milliseconds.\r\n\t */\r\n\tpublic ttl: number = 1000;\r\n\r\n\t/**\r\n\t * Caches or updates cached value, resets TTL.\r\n\t *\r\n\t * If `ttl` is set to zero, item will never expire.\r\n\t *\r\n\t * @param owner  An id of the object that owns this cache\r\n\t * @param key    Index key\r\n\t * @param value  Value\r\n\t * @param ttl    TTL of the cache to live in milliseconds\r\n\t */\r\n\tpublic set(owner: string, key: string, value: A, ttl?: number): void {\r\n\r\n\t\t// Create if storage does not exist for this owner\r\n\t\tlet ownerStorage = this._storage.insertKeyIfEmpty(owner, () => new Dictionary<string, CacheItem<A>>());\r\n\r\n\t\t// Create cache item\r\n\t\tlet item: CacheItem<A> = {\r\n\t\t\t\"touched\": new Date().getTime(),\r\n\t\t\t\"ttl\": $type.isNumber(ttl) ? ttl : this.ttl,\r\n\t\t\t\"value\": value\r\n\t\t};\r\n\r\n\t\t// Set\r\n\t\townerStorage.setKey(key, item);\r\n\t}\r\n\r\n\t/**\r\n\t * Rerturns cached item, respecting TTL.\r\n\t *\r\n\t * @param owner  An id of the object that owns this cache\r\n\t * @param key    Index key\r\n\t * @param value  Value to return if cache not available\r\n\t * @return Value, or `undefined` if not set\r\n\t */\r\n\tpublic get(owner: string, key: string, value: any = undefined): $type.Optional<A> {\r\n\t\t// \t\t || ypeof this._storage[owner][key] === \"undefined\" || this._storage[owner][key].expired === true) {\r\n\t\tif (this._storage.hasKey(owner)) {\r\n\t\t\tlet ownerStorage = <Dictionary<string, CacheItem<A>>>this._storage.getKey(owner);\r\n\r\n\t\t\tif (ownerStorage.hasKey(key)) {\r\n\t\t\t\tlet cacheItem: CacheItem<A> = <CacheItem<A>>ownerStorage.getKey(key);\r\n\t\t\t\tif (cacheItem.ttl && ((cacheItem.touched + cacheItem.ttl) < new Date().getTime())) {\r\n\t\t\t\t\tcacheItem.expired = true;\r\n\t\t\t\t}\r\n\t\t\t\tif (cacheItem.expired) {\r\n\t\t\t\t\townerStorage.removeKey(key);\r\n\t\t\t\t\treturn value;\r\n\t\t\t\t}\r\n\t\t\t\treturn cacheItem.value;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\treturn value;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn value;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Clears cache for specific owner or everything.\r\n\t *\r\n\t * @param owner Owner to clear cache for\r\n\t */\r\n\tpublic clear(owner?: string): void {\r\n\t\tif (owner) {\r\n\t\t\tthis._storage.removeKey(owner);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis._storage.clear();\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * ============================================================================\r\n * GLOBAL INSTANCE\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * A global instance of cache. Use this instance to cache any values.\r\n *\r\n * @ignore Exclude from docs\r\n */\r\nexport let cache: Cache<any> = new Cache();\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}