{"ast":null,"code":"import { EventDispatcher } from \"./utils/EventDispatcher\";\nimport { Dictionary } from \"./utils/Dictionary\";\nimport { cache } from \"./utils/Cache\";\nimport * as $type from \"./utils/Type\";\nimport * as $string from \"./utils/String\";\nimport * as $array from \"./utils/Array\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Registry is used to store miscellaneous system-wide information, like ids,\r\n * maps, themes, and registered classes.\r\n *\r\n * @ignore Exclude from docs\r\n */\n\nvar Registry =\n/** @class */\nfunction () {\n  function Registry() {\n    var _this = this;\n    /**\r\n     * Event dispacther.\r\n     */\n\n\n    this.events = new EventDispatcher();\n    /**\r\n     * All currently applied themes. All new chart instances created will\r\n     * automatically inherit and retain System's themes.\r\n     */\n\n    this.themes = [];\n    /**\r\n     * List of all loaded available themes.\r\n     *\r\n     * Whenever a theme loads, it registers itself in System's `loadedThemes`\r\n     * collection.\r\n     */\n\n    this.loadedThemes = {};\n    /**\r\n     * An indeternal counter used to generate unique IDs.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    this._uidCount = 0;\n    /**\r\n     * Keeps register of class references so that they can be instnatiated using\r\n     * string key.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    this.registeredClasses = {};\n    /**\r\n     * Holds all generated placeholders.\r\n     */\n\n    this._placeholders = {};\n    /**\r\n     * A list of invalid(ated) [[Sprite]] objects that need to be re-validated\r\n     * during next cycle.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    this.invalidSprites = {};\n    /**\r\n     * Components are added to this list when their data provider changes to\r\n     * a new one or data is added/removed from their data provider.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    this.invalidDatas = {};\n    /**\r\n     * Components are added to this list when values of their raw data change.\r\n     * Used when we want a smooth animation from one set of values to another.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    this.invalidRawDatas = [];\n    /**\r\n     * Components are added to this list when values of their data changes\r\n     * (but not data provider itself).\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    this.invalidDataItems = [];\n    /**\r\n     * Components are added to this list when their data range (selection) is\r\n     * changed, e.g. zoomed.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    this.invalidDataRange = [];\n    /**\r\n     * A list of [[Sprite]] objects that have invalid(ated) positions, that need\r\n     * to be recalculated.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    this.invalidPositions = {};\n    /**\r\n     * A list of [[Container]] objects with invalid(ated) layouts.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    this.invalidLayouts = {};\n    /**\r\n     * An array holding all active (non-disposed) top level elemens.\r\n     *\r\n     * When, for example, a new chart is created, its instance will be added to\r\n     * this array, and will be removed when the chart is disposed.\r\n     */\n\n    this.baseSprites = [];\n    /**\r\n     * An UID-based map of base sprites (top-level charts).\r\n     */\n\n    this.baseSpritesByUid = {};\n    /**\r\n     * Queued charts (waiting for their turn) to initialize.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/performance/#Daisy_chaining_multiple_charts} for more information\r\n     */\n\n    this.queue = [];\n    /**\r\n     * An array of deferred charts that haven't been created yet.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/performance/#Deferred_daisy_chained_instantiation} for more information\r\n     * @since 4.10.0\r\n     */\n\n    this.deferred = [];\n    this.uid = this.getUniqueId();\n    this.invalidSprites.noBase = [];\n    this.invalidDatas.noBase = [];\n    this.invalidLayouts.noBase = [];\n    this.invalidPositions.noBase = []; // This is needed for Angular Universal SSR\n\n    if (typeof addEventListener !== \"undefined\") {\n      // This is needed to prevent charts from being cut off when printing\n      addEventListener(\"beforeprint\", function () {\n        $array.each(_this.baseSprites, function (sprite) {\n          var svg = sprite.paper.svg;\n          svg.setAttribute(\"viewBox\", \"0 0 \" + svg.clientWidth + \" \" + svg.clientHeight);\n        });\n      });\n      addEventListener(\"afterprint\", function () {\n        $array.each(_this.baseSprites, function (sprite) {\n          var svg = sprite.paper.svg;\n          svg.removeAttribute(\"viewBox\");\n        });\n      });\n    }\n  }\n  /**\r\n   * Generates a unique chart system-wide ID.\r\n   *\r\n   * @return Generated ID\r\n   */\n\n\n  Registry.prototype.getUniqueId = function () {\n    var uid = this._uidCount;\n    this._uidCount += 1;\n    return \"id-\" + uid;\n  };\n\n  Object.defineProperty(Registry.prototype, \"map\", {\n    /**\r\n     * Returns a universal collection for mapping ids with objects.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @return Map collection\r\n     */\n    get: function () {\n      if (!this._map) {\n        this._map = new Dictionary();\n      }\n\n      return this._map;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Caches value in object's cache.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param key    Key\r\n   * @param value  Value\r\n   * @param ttl    TTL in seconds\r\n   */\n\n  Registry.prototype.setCache = function (key, value, ttl) {\n    cache.set(this.uid, key, value, ttl);\n  };\n  /**\r\n   * Retrieves cached value.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param key    Key\r\n   * @param value  Value to return if cache is not available\r\n   * @return Value\r\n   */\n\n\n  Registry.prototype.getCache = function (key, value) {\n    if (value === void 0) {\n      value = undefined;\n    }\n\n    return cache.get(this.uid, key, value);\n  };\n  /**\r\n   * Dispatches an event using own event dispatcher. Will automatically\r\n   * populate event data object with event type and target (this element).\r\n   * It also checks if there are any handlers registered for this sepecific\r\n   * event.\r\n   *\r\n   * @param eventType Event type (name)\r\n   * @param data      Data to pass into event handler(s)\r\n   */\n\n\n  Registry.prototype.dispatch = function (eventType, data) {\n    // @todo Implement proper type check\n    if (this.events.isEnabled(eventType)) {\n      if (data) {\n        data.type = eventType;\n        data.target = data.target || this;\n        this.events.dispatch(eventType, {\n          type: eventType,\n          target: this\n        });\n      } else {\n        this.events.dispatch(eventType, {\n          type: eventType,\n          target: this\n        });\n      }\n    }\n  };\n  /**\r\n   * Works like `dispatch`, except event is triggered immediately, without\r\n   * waiting for the next frame cycle.\r\n   *\r\n   * @param eventType Event type (name)\r\n   * @param data      Data to pass into event handler(s)\r\n   */\n\n\n  Registry.prototype.dispatchImmediately = function (eventType, data) {\n    // @todo Implement proper type check\n    if (this.events.isEnabled(eventType)) {\n      if (data) {\n        data.type = eventType;\n        data.target = data.target || this;\n        this.events.dispatchImmediately(eventType, data);\n      } else {\n        this.events.dispatchImmediately(eventType, {\n          type: eventType,\n          target: this\n        });\n      }\n    }\n  };\n  /**\r\n   * Returns a unique placeholder suitable for the key.\r\n   *\r\n   * @param key  Key\r\n   * @return Random string to be used as placeholder\r\n   */\n\n\n  Registry.prototype.getPlaceholder = function (key) {\n    if ($type.hasValue(this._placeholders[key])) {\n      return this._placeholders[key];\n    }\n\n    this._placeholders[key] = \"__amcharts_\" + key + \"_\" + $string.random(8) + \"__\";\n    return this._placeholders[key];\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  Registry.prototype.addToInvalidComponents = function (component) {\n    if (component.baseId) {\n      $array.move(this.invalidDatas[component.baseId], component);\n    } else {\n      $array.move(this.invalidDatas[\"noBase\"], component);\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  Registry.prototype.removeFromInvalidComponents = function (component) {\n    if (component.baseId) {\n      $array.remove(this.invalidDatas[component.baseId], component);\n    }\n\n    $array.remove(this.invalidDatas[\"noBase\"], component);\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  Registry.prototype.addToInvalidSprites = function (sprite) {\n    if (sprite.baseId) {\n      $array.add(this.invalidSprites[sprite.baseId], sprite);\n    } else {\n      $array.add(this.invalidSprites[\"noBase\"], sprite);\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  Registry.prototype.removeFromInvalidSprites = function (sprite) {\n    if (sprite.baseId) {\n      $array.remove(this.invalidSprites[sprite.baseId], sprite);\n    }\n\n    $array.remove(this.invalidSprites[\"noBase\"], sprite);\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  Registry.prototype.addToInvalidPositions = function (sprite) {\n    if (sprite.baseId) {\n      $array.add(this.invalidPositions[sprite.baseId], sprite);\n    } else {\n      $array.add(this.invalidPositions[\"noBase\"], sprite);\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  Registry.prototype.removeFromInvalidPositions = function (sprite) {\n    if (sprite.baseId) {\n      $array.remove(this.invalidPositions[sprite.baseId], sprite);\n    }\n\n    $array.remove(this.invalidPositions[\"noBase\"], sprite);\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  Registry.prototype.addToInvalidLayouts = function (sprite) {\n    if (sprite.baseId) {\n      $array.add(this.invalidLayouts[sprite.baseId], sprite);\n    } else {\n      $array.add(this.invalidLayouts[\"noBase\"], sprite);\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  Registry.prototype.removeFromInvalidLayouts = function (sprite) {\n    if (sprite.baseId) {\n      $array.remove(this.invalidLayouts[sprite.baseId], sprite);\n    }\n\n    $array.remove(this.invalidLayouts[\"noBase\"], sprite);\n  };\n\n  return Registry;\n}();\n\nexport { Registry };\n/**\r\n * A singleton global instance of [[Registry]].\r\n *\r\n * @ignore Exclude from docs\r\n */\n\nexport var registry = new Registry();\n/**\r\n * Returns `true` if object is an instance of the class. It's the same as `instanceof` except it doesn't need to import the class.\r\n *\r\n * @param object Object\r\n * @param name Class name\r\n * @return Is instance of class\r\n */\n\nexport function is(object, name) {\n  var x = registry.registeredClasses[name];\n  return x != null && object instanceof x;\n}","map":{"version":3,"sources":["../../../../src/.internal/core/Registry.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { ITheme } from \"../themes/ITheme\";\r\nimport { EventDispatcher, AMEvent } from \"./utils/EventDispatcher\";\r\nimport { Dictionary } from \"./utils/Dictionary\";\r\nimport { Sprite } from \"./Sprite\";\r\nimport { Container } from \"./Container\";\r\nimport { Component } from \"./Component\";\r\nimport { cache } from \"./utils/Cache\";\r\nimport * as $type from \"./utils/Type\";\r\nimport * as $string from \"./utils/String\";\r\nimport * as $array from \"./utils/Array\";\r\n\r\n\r\n/**\r\n * Define events available for [[Registry]]\r\n */\r\nexport interface IRegistryEvents {\r\n\r\n\t/**\r\n\t * Invoked when update cycle starts. Before invalid elements are re-validated.\r\n\t */\r\n\tenterframe: {};\r\n\r\n\t/**\r\n\t * Invoked when udpate cycle ends. After invalid elements have been\r\n\t * re-validated.\r\n\t */\r\n\texitframe: {};\r\n\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Registry is used to store miscellaneous system-wide information, like ids,\r\n * maps, themes, and registered classes.\r\n *\r\n * @ignore Exclude from docs\r\n */\r\nexport class Registry {\r\n\r\n\t/**\r\n\t * Unique ID of the object.\r\n\t */\r\n\tpublic uid: string;\r\n\r\n\t/**\r\n\t * Event dispacther.\r\n\t */\r\n\tpublic events: EventDispatcher<AMEvent<Registry, IRegistryEvents>> = new EventDispatcher();\r\n\r\n\t/**\r\n\t * Holds a universal mapping collection, so that elements and their children\r\n\t * can create and look up all kinds of relations between id and object.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tprotected _map: $type.Optional<Dictionary<string, any>>;\r\n\r\n\t/**\r\n\t * All currently applied themes. All new chart instances created will\r\n\t * automatically inherit and retain System's themes.\r\n\t */\r\n\tpublic themes: ITheme[] = [];\r\n\r\n\t/**\r\n\t * List of all loaded available themes.\r\n\t *\r\n\t * Whenever a theme loads, it registers itself in System's `loadedThemes`\r\n\t * collection.\r\n\t */\r\n\tpublic loadedThemes: { [index: string]: ITheme } = {};\r\n\r\n\t/**\r\n\t * An indeternal counter used to generate unique IDs.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tprotected _uidCount: number = 0;\r\n\r\n\t/**\r\n\t * Keeps register of class references so that they can be instnatiated using\r\n\t * string key.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic registeredClasses: { [index: string]: any } = {};\r\n\r\n\t/**\r\n\t * Holds all generated placeholders.\r\n\t */\r\n\tprotected _placeholders: { [index: string]: string } = {};\r\n\r\n\t/**\r\n\t * A list of invalid(ated) [[Sprite]] objects that need to be re-validated\r\n\t * during next cycle.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic invalidSprites: { [index: string]: Array<Sprite> } = {};\r\n\r\n\t/**\r\n\t * Components are added to this list when their data provider changes to\r\n\t * a new one or data is added/removed from their data provider.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic invalidDatas: { [index: string]: Array<Component> } = {};\r\n\r\n\t/**\r\n\t * Components are added to this list when values of their raw data change.\r\n\t * Used when we want a smooth animation from one set of values to another.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic invalidRawDatas: Array<Component> = [];\r\n\r\n\t/**\r\n\t * Components are added to this list when values of their data changes\r\n\t * (but not data provider itself).\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic invalidDataItems: Array<Component> = [];\r\n\r\n\t/**\r\n\t * Components are added to this list when their data range (selection) is\r\n\t * changed, e.g. zoomed.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic invalidDataRange: Array<Component> = [];\r\n\r\n\t/**\r\n\t * A list of [[Sprite]] objects that have invalid(ated) positions, that need\r\n\t * to be recalculated.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic invalidPositions: { [index: string]: Array<Sprite> } = {};\r\n\r\n\t/**\r\n\t * A list of [[Container]] objects with invalid(ated) layouts.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic invalidLayouts: { [index: string]: Array<Container> } = {};\r\n\r\n\t/**\r\n\t * An array holding all active (non-disposed) top level elemens.\r\n\t *\r\n\t * When, for example, a new chart is created, its instance will be added to\r\n\t * this array, and will be removed when the chart is disposed.\r\n\t */\r\n\tpublic baseSprites: Array<Sprite> = [];\r\n\r\n\t/**\r\n\t * An UID-based map of base sprites (top-level charts).\r\n\t */\r\n\tpublic baseSpritesByUid: { [index: string]: Sprite } = {};\r\n\r\n\t/**\r\n\t * Queued charts (waiting for their turn) to initialize.\r\n\t * \r\n\t * @see {@link https://www.amcharts.com/docs/v4/concepts/performance/#Daisy_chaining_multiple_charts} for more information\r\n\t */\r\n\tpublic queue: Array<Sprite> = [];\r\n\r\n\t/**\r\n\t * An array of deferred charts that haven't been created yet.\r\n\t *\r\n\t * @see {@link https://www.amcharts.com/docs/v4/concepts/performance/#Deferred_daisy_chained_instantiation} for more information\r\n\t * @since 4.10.0\r\n\t */\r\n\tpublic deferred: Array<{\r\n\t\tcallback: (...args: Array<any>) => Sprite,\r\n\t\tscope?: any,\r\n\t\targs?: Array<any>,\r\n\t\tresolve: any\r\n\t}> = [];\r\n\r\n\tconstructor() {\r\n\t\tthis.uid = this.getUniqueId();\r\n\r\n\t\tthis.invalidSprites.noBase = [];\r\n\t\tthis.invalidDatas.noBase = [];\r\n\t\tthis.invalidLayouts.noBase = [];\r\n\t\tthis.invalidPositions.noBase = [];\r\n\r\n\t\t// This is needed for Angular Universal SSR\r\n\t\tif (typeof addEventListener !== \"undefined\") {\r\n\t\t\t// This is needed to prevent charts from being cut off when printing\r\n\t\t\taddEventListener(\"beforeprint\", () => {\r\n\t\t\t\t$array.each(this.baseSprites, (sprite) => {\r\n\t\t\t\t\tconst svg = sprite.paper.svg;\r\n\t\t\t\t\tsvg.setAttribute(\"viewBox\", \"0 0 \" + svg.clientWidth + \" \" + svg.clientHeight);\r\n\t\t\t\t});\r\n\t\t\t});\r\n\r\n\t\t\taddEventListener(\"afterprint\", () => {\r\n\t\t\t\t$array.each(this.baseSprites, (sprite) => {\r\n\t\t\t\t\tconst svg = sprite.paper.svg;\r\n\t\t\t\t\tsvg.removeAttribute(\"viewBox\");\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Generates a unique chart system-wide ID.\r\n\t *\r\n\t * @return Generated ID\r\n\t */\r\n\tpublic getUniqueId(): string {\r\n\t\tlet uid = this._uidCount;\r\n\t\tthis._uidCount += 1;\r\n\t\treturn \"id-\" + uid;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a universal collection for mapping ids with objects.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @return Map collection\r\n\t */\r\n\tpublic get map(): Dictionary<string, any> {\r\n\t\tif (!this._map) {\r\n\t\t\tthis._map = new Dictionary<string, any>();\r\n\t\t}\r\n\t\treturn this._map;\r\n\t}\r\n\r\n\t/**\r\n\t * Caches value in object's cache.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param key    Key\r\n\t * @param value  Value\r\n\t * @param ttl    TTL in seconds\r\n\t */\r\n\tpublic setCache(key: string, value: any, ttl?: number): void {\r\n\t\tcache.set(this.uid, key, value, ttl);\r\n\t}\r\n\r\n\t/**\r\n\t * Retrieves cached value.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param key    Key\r\n\t * @param value  Value to return if cache is not available\r\n\t * @return Value\r\n\t */\r\n\tpublic getCache(key: string, value: any = undefined): any {\r\n\t\treturn cache.get(this.uid, key, value);\r\n\t}\r\n\r\n\t/**\r\n\t * Dispatches an event using own event dispatcher. Will automatically\r\n\t * populate event data object with event type and target (this element).\r\n\t * It also checks if there are any handlers registered for this sepecific\r\n\t * event.\r\n\t *\r\n\t * @param eventType Event type (name)\r\n\t * @param data      Data to pass into event handler(s)\r\n\t */\r\n\tpublic dispatch<Key extends keyof IRegistryEvents>(eventType: Key, data?: any): void {\r\n\t\t// @todo Implement proper type check\r\n\t\tif (this.events.isEnabled(eventType)) {\r\n\t\t\tif (data) {\r\n\t\t\t\tdata.type = eventType;\r\n\t\t\t\tdata.target = data.target || this;\r\n\t\t\t\t(<any>this.events).dispatch(eventType, {\r\n\t\t\t\t\ttype: eventType,\r\n\t\t\t\t\ttarget: this\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t(<any>this.events).dispatch(eventType, {\r\n\t\t\t\t\ttype: eventType,\r\n\t\t\t\t\ttarget: this\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Works like `dispatch`, except event is triggered immediately, without\r\n\t * waiting for the next frame cycle.\r\n\t *\r\n\t * @param eventType Event type (name)\r\n\t * @param data      Data to pass into event handler(s)\r\n\t */\r\n\tpublic dispatchImmediately<Key extends keyof IRegistryEvents>(eventType: Key, data?: any): void {\r\n\t\t// @todo Implement proper type check\r\n\t\tif (this.events.isEnabled(eventType)) {\r\n\t\t\tif (data) {\r\n\t\t\t\tdata.type = eventType;\r\n\t\t\t\tdata.target = data.target || this;\r\n\t\t\t\t(<any>this.events).dispatchImmediately(eventType, data);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t(<any>this.events).dispatchImmediately(eventType, {\r\n\t\t\t\t\ttype: eventType,\r\n\t\t\t\t\ttarget: this\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a unique placeholder suitable for the key.\r\n\t *\r\n\t * @param key  Key\r\n\t * @return Random string to be used as placeholder\r\n\t */\r\n\tpublic getPlaceholder(key: string): string {\r\n\t\tif ($type.hasValue(this._placeholders[key])) {\r\n\t\t\treturn this._placeholders[key];\r\n\t\t}\r\n\t\tthis._placeholders[key] = \"__amcharts_\" + key + \"_\" + $string.random(8) + \"__\";\r\n\t\treturn this._placeholders[key];\r\n\t}\r\n\r\n\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic addToInvalidComponents(component: Component) {\r\n\t\tif (component.baseId) {\r\n\t\t\t$array.move(this.invalidDatas[component.baseId], component);\r\n\t\t}\r\n\t\telse {\r\n\t\t\t$array.move(this.invalidDatas[\"noBase\"], component);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic removeFromInvalidComponents(component: Component) {\r\n\t\tif (component.baseId) {\r\n\t\t\t$array.remove(this.invalidDatas[component.baseId], component);\r\n\t\t}\r\n\r\n\t\t$array.remove(this.invalidDatas[\"noBase\"], component);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic addToInvalidSprites(sprite: Sprite) {\r\n\t\tif (sprite.baseId) {\r\n\t\t\t$array.add(this.invalidSprites[sprite.baseId], sprite);\r\n\t\t}\r\n\t\telse {\r\n\t\t\t$array.add(this.invalidSprites[\"noBase\"], sprite);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic removeFromInvalidSprites(sprite: Sprite) {\r\n\t\tif (sprite.baseId) {\r\n\t\t\t$array.remove(this.invalidSprites[sprite.baseId], sprite);\r\n\t\t}\r\n\r\n\t\t$array.remove(this.invalidSprites[\"noBase\"], sprite);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic addToInvalidPositions(sprite: Sprite) {\r\n\t\tif (sprite.baseId) {\r\n\t\t\t$array.add(this.invalidPositions[sprite.baseId], sprite);\r\n\t\t}\r\n\t\telse {\r\n\t\t\t$array.add(this.invalidPositions[\"noBase\"], sprite);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic removeFromInvalidPositions(sprite: Sprite) {\r\n\t\tif (sprite.baseId) {\r\n\t\t\t$array.remove(this.invalidPositions[sprite.baseId], sprite);\r\n\t\t}\r\n\r\n\t\t$array.remove(this.invalidPositions[\"noBase\"], sprite);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic addToInvalidLayouts(sprite: Container) {\r\n\t\tif (sprite.baseId) {\r\n\t\t\t$array.add(this.invalidLayouts[sprite.baseId], sprite);\r\n\t\t}\r\n\t\telse {\r\n\t\t\t$array.add(this.invalidLayouts[\"noBase\"], sprite);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic removeFromInvalidLayouts(sprite: Container) {\r\n\t\tif (sprite.baseId) {\r\n\t\t\t$array.remove(this.invalidLayouts[sprite.baseId], sprite);\r\n\t\t}\r\n\r\n\t\t$array.remove(this.invalidLayouts[\"noBase\"], sprite);\r\n\t}\r\n}\r\n\r\n/**\r\n * A singleton global instance of [[Registry]].\r\n *\r\n * @ignore Exclude from docs\r\n */\r\nexport let registry = new Registry();\r\n\r\n\r\n/**\r\n * Returns `true` if object is an instance of the class. It's the same as `instanceof` except it doesn't need to import the class.\r\n *\r\n * @param object Object\r\n * @param name Class name\r\n * @return Is instance of class\r\n */\r\nexport function is<A>(object: any, name: string): object is A {\r\n\tconst x = registry.registeredClasses[name];\r\n\treturn x != null && object instanceof x;\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}